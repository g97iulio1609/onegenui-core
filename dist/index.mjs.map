{"version":3,"sources":["../src/types.ts","../src/visibility.ts","../src/actions.ts","../src/validation.ts","../src/catalog.ts","../src/component.ts","../src/prompt/schema-describer.ts","../src/prompt/rules-generator.ts","../src/prompt/interactive-rules.ts","../src/prompt/context-prompts.ts","../src/prompt-generator.ts","../src/streaming/schemas.ts","../src/streaming/validation.ts","../src/streaming/patch-buffer.ts","../src/streaming/placeholder-manager.ts","../src/streaming/ports.ts","../src/ports/cache.ts","../src/ports/memory.ts","../src/ports/sync.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { getByPath } from \"@onegenui/utils\";\n\n// Re-export for convenience\nexport { getByPath } from \"@onegenui/utils\";\n\n/**\n * Dynamic value - can be a literal or a path reference to data model\n */\nexport type DynamicValue<T = unknown> = T | { path: string };\n\n/**\n * Dynamic string value\n */\nexport type DynamicString = DynamicValue<string>;\n\n/**\n * Dynamic number value\n */\nexport type DynamicNumber = DynamicValue<number>;\n\n/**\n * Dynamic boolean value\n */\nexport type DynamicBoolean = DynamicValue<boolean>;\n\n/**\n * Zod schema for dynamic values\n */\nexport const DynamicValueSchema = z.union([\n  z.string(),\n  z.number(),\n  z.boolean(),\n  z.null(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicStringSchema = z.union([\n  z.string(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicNumberSchema = z.union([\n  z.number(),\n  z.object({ path: z.string() }),\n]);\n\nexport const DynamicBooleanSchema = z.union([\n  z.boolean(),\n  z.object({ path: z.string() }),\n]);\n\n/**\n * Sizing configuration for UI elements\n */\nexport interface ElementSize {\n  /** Width in pixels or CSS value */\n  width?: number | string;\n  /** Height in pixels or CSS value */\n  height?: number | string;\n  /** Minimum width in pixels */\n  minWidth?: number;\n  /** Maximum width in pixels */\n  maxWidth?: number;\n  /** Minimum height in pixels */\n  minHeight?: number;\n  /** Maximum height in pixels */\n  maxHeight?: number;\n}\n\n/**\n * Grid layout configuration for UI elements\n */\nexport interface ElementGridLayout {\n  /** Grid column start (1-indexed) */\n  column?: number;\n  /** Grid row start (1-indexed) */\n  row?: number;\n  /** Number of columns to span */\n  columnSpan?: number;\n  /** Number of rows to span */\n  rowSpan?: number;\n}\n\n/**\n * Resize configuration for UI elements\n */\nexport interface ElementResizeConfig {\n  /** Enable horizontal resize */\n  horizontal?: boolean;\n  /** Enable vertical resize */\n  vertical?: boolean;\n  /** Snap to grid size in pixels */\n  snapToGrid?: number;\n  /** Preserve aspect ratio */\n  preserveAspectRatio?: boolean;\n}\n\n/**\n * Complete layout configuration for UI elements\n */\nexport interface ElementLayout {\n  /** Explicit sizing */\n  size?: ElementSize;\n  /** Grid positioning */\n  grid?: ElementGridLayout;\n  /** Resize behavior */\n  resizable?: boolean | ElementResizeConfig;\n}\n\n/**\n * Base UI element structure for v2\n */\nexport interface UIElement<\n  T extends string = string,\n  P = Record<string, unknown>,\n> {\n  /** Unique key for reconciliation */\n  key: string;\n  /** Component type from the catalog */\n  type: T;\n  /** Component props */\n  props: P;\n  /** Child element keys (flat structure) */\n  children?: string[];\n  /** Parent element key (null for root) */\n  parentKey?: string | null;\n  /** Visibility condition */\n  visible?: VisibilityCondition;\n  /** If true, content editing is disabled for this element */\n  locked?: boolean;\n  /** Layout configuration (sizing, grid position, resize) */\n  layout?: ElementLayout;\n  /** System metadata (turnId for chronological ordering, etc.) */\n  _meta?: {\n    turnId?: string;\n    createdAt?: number;\n  };\n}\n\n/**\n * Visibility condition types\n */\nexport type VisibilityCondition =\n  | boolean\n  | { path: string }\n  | { auth: \"signedIn\" | \"signedOut\" }\n  | { role: string | string[] }\n  | { feature: string | string[] }\n  | {\n      device:\n        | \"mobile\"\n        | \"tablet\"\n        | \"desktop\"\n        | (\"mobile\" | \"tablet\" | \"desktop\")[];\n    }\n  | LogicExpression;\n\n/**\n * Logic expression for complex conditions\n */\nexport type LogicExpression =\n  | { and: LogicExpression[] }\n  | { or: LogicExpression[] }\n  | { not: LogicExpression }\n  | { path: string }\n  | { eq: [DynamicValue, DynamicValue] }\n  | { neq: [DynamicValue, DynamicValue] }\n  | { gt: [DynamicValue<number>, DynamicValue<number>] }\n  | { gte: [DynamicValue<number>, DynamicValue<number>] }\n  | { lt: [DynamicValue<number>, DynamicValue<number>] }\n  | { lte: [DynamicValue<number>, DynamicValue<number>] };\n\n/**\n * Flat UI tree structure (optimized for LLM generation)\n */\nexport interface UITree {\n  /** Root element key */\n  root: string;\n  /** Flat map of elements by key */\n  elements: Record<string, UIElement>;\n}\n\n/**\n * Auth state for visibility evaluation\n */\nexport interface AuthState {\n  isSignedIn: boolean;\n  user?: Record<string, unknown>;\n  roles?: string[];\n}\n\n/**\n * Feature flags state\n */\nexport interface FeatureFlags {\n  enabled: string[];\n}\n\n/**\n * Device detection state\n */\nexport interface DeviceState {\n  type: \"mobile\" | \"tablet\" | \"desktop\";\n  isTouchDevice?: boolean;\n}\n\n/**\n * Data model type\n */\nexport type DataModel = Record<string, unknown>;\n\n/**\n * Component schema definition using Zod\n */\nexport type ComponentSchema = z.ZodType<Record<string, unknown>>;\n\n/**\n * Validation mode for catalog validation\n */\nexport type ValidationMode = \"strict\" | \"warn\" | \"ignore\";\n\n/**\n * JSON patch operation types\n */\nexport type PatchOp =\n  | \"add\"\n  | \"remove\"\n  | \"replace\"\n  | \"set\"\n  | \"ensure\"\n  | \"message\"\n  | \"question\"\n  | \"suggestion\";\n\n/**\n * JSON patch operation\n */\nexport interface JsonPatch {\n  op: PatchOp;\n  path: string;\n  value?: unknown;\n  /** Question payload (for op: \"question\") */\n  question?: unknown;\n  /** Suggestions array (for op: \"suggestion\") */\n  suggestions?: unknown[];\n}\n\n/**\n * Zod schema for JSON patch\n */\nexport const JsonPatchSchema = z.object({\n  op: z.enum([\n    \"add\",\n    \"remove\",\n    \"replace\",\n    \"set\",\n    \"message\",\n    \"question\",\n    \"suggestion\",\n  ]),\n  path: z.string().optional(),\n  value: z.unknown().optional(),\n  question: z.unknown().optional(),\n  suggestions: z.array(z.unknown()).optional(),\n});\n\n/**\n * Resolve a dynamic value against a data model\n */\nexport function resolveDynamicValue<T>(\n  value: DynamicValue<T>,\n  dataModel: DataModel,\n): T | undefined {\n  if (value === null || value === undefined) {\n    return undefined;\n  }\n\n  if (typeof value === \"object\" && \"path\" in value) {\n    return getByPath(dataModel, value.path) as T | undefined;\n  }\n\n  return value as T;\n}\n\n/**\n * Set a value in an object by JSON Pointer path\n */\nexport function setByPath(\n  obj: Record<string, unknown>,\n  path: string,\n  value: unknown,\n): void {\n  const segments = path.startsWith(\"/\")\n    ? path.slice(1).split(\"/\")\n    : path.split(\"/\");\n\n  if (segments.length === 0) return;\n\n  const isArraySegment = (segment: string) =>\n    segment === \"-\" || /^\\d+$/.test(segment);\n\n  let current: Record<string, unknown> | unknown[] = obj;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    const segment = segments[i]!;\n    const nextSegment = segments[i + 1]!;\n    const shouldCreateArray = isArraySegment(nextSegment);\n\n    if (Array.isArray(current)) {\n      const index = segment === \"-\" ? current.length : Number(segment);\n      if (!Number.isInteger(index) || index < 0) return;\n\n      const existing = current[index];\n      if (existing === null || typeof existing !== \"object\") {\n        current[index] = shouldCreateArray ? [] : {};\n      }\n\n      const nextValue = current[index];\n      if (Array.isArray(nextValue) || typeof nextValue === \"object\") {\n        current = nextValue as Record<string, unknown> | unknown[];\n      } else {\n        return;\n      }\n    } else {\n      if (\n        !(segment in current) ||\n        current[segment] === null ||\n        typeof current[segment] !== \"object\"\n      ) {\n        current[segment] = shouldCreateArray ? [] : {};\n      }\n\n      const nextValue = current[segment];\n      if (Array.isArray(nextValue) || typeof nextValue === \"object\") {\n        current = nextValue as Record<string, unknown> | unknown[];\n      } else {\n        return;\n      }\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]!;\n\n  if (Array.isArray(current)) {\n    if (lastSegment === \"-\") {\n      current.push(value);\n      return;\n    }\n\n    const index = Number(lastSegment);\n    if (!Number.isInteger(index) || index < 0) return;\n    current[index] = value;\n    return;\n  }\n\n  current[lastSegment] = value;\n}\n\n// ─────────────────────────────────────────────────────────────────────────────\n// Document Index Types (Vectorless)\n// ─────────────────────────────────────────────────────────────────────────────\n\n/**\n * A node in the document index tree\n */\nexport interface DocumentIndexNode {\n  /** Node title/heading */\n  title: string;\n  /** Unique identifier */\n  nodeId: string;\n  /** Starting page number */\n  startPage: number;\n  /** Ending page number */\n  endPage: number;\n  /** Summary of the section content */\n  summary?: string;\n  /** Child nodes */\n  children?: DocumentIndexNode[];\n}\n\n/**\n * Document index data from Vectorless smart parsing\n */\nexport interface DocumentIndex {\n  /** Document title */\n  title: string;\n  /** Document description */\n  description: string;\n  /** Total page count */\n  pageCount: number;\n  /** Hierarchical index nodes */\n  nodes: DocumentIndexNode[];\n}\n\n/**\n * Stream event types for document processing\n */\nexport type StreamEventType =\n  | \"tool-progress\"\n  | \"document-index-ui\"\n  | \"persisted-attachments\"\n  | \"plan-created\"\n  | \"level-started\"\n  | \"step-started\"\n  | \"step-done\"\n  | \"subtask-started\"\n  | \"subtask-done\"\n  | \"orchestration-done\";\n\n/**\n * Tool progress status\n */\nexport type ToolProgressStatus = \"starting\" | \"progress\" | \"complete\" | \"error\";\n\n/**\n * Tool progress stream event\n */\nexport interface ToolProgressEvent {\n  type: \"tool-progress\";\n  toolName: string;\n  toolCallId: string;\n  status: ToolProgressStatus;\n  message?: string;\n  data?: unknown;\n  progress?: number; // 0-100\n  timestamp?: number;\n}\n\n/**\n * Document index UI stream event\n */\nexport interface DocumentIndexEvent {\n  type: \"document-index-ui\";\n  uiComponent: {\n    type: \"DocumentIndex\";\n    props: DocumentIndex;\n  };\n}\n","import { z } from \"zod\";\nimport type {\n  VisibilityCondition,\n  LogicExpression,\n  DataModel,\n  AuthState,\n  FeatureFlags,\n  DeviceState,\n  DynamicValue,\n} from \"./types\";\nimport { resolveDynamicValue, DynamicValueSchema } from \"./types\";\n\n// Dynamic value schema for comparisons (number-focused)\nconst DynamicNumberValueSchema = z.union([\n  z.number(),\n  z.object({ path: z.string() }),\n]);\n\n/**\n * Logic expression schema (recursive)\n * Using a more permissive schema that aligns with runtime behavior\n */\nexport const LogicExpressionSchema: z.ZodType<LogicExpression> = z.lazy(() =>\n  z.union([\n    z.object({ and: z.array(LogicExpressionSchema) }),\n    z.object({ or: z.array(LogicExpressionSchema) }),\n    z.object({ not: LogicExpressionSchema }),\n    z.object({ path: z.string() }),\n    z.object({ eq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\n    z.object({ neq: z.tuple([DynamicValueSchema, DynamicValueSchema]) }),\n    z.object({\n      gt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      gte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      lt: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n    z.object({\n      lte: z.tuple([DynamicNumberValueSchema, DynamicNumberValueSchema]),\n    }),\n  ]),\n) as z.ZodType<LogicExpression>;\n\nconst deviceTypeSchema = z.enum([\"mobile\", \"tablet\", \"desktop\"]);\n\n/**\n * Visibility condition schema\n */\nexport const VisibilityConditionSchema: z.ZodType<VisibilityCondition> =\n  z.union([\n    z.boolean(),\n    z.object({ path: z.string() }),\n    z.object({ auth: z.enum([\"signedIn\", \"signedOut\"]) }),\n    z.object({ role: z.union([z.string(), z.array(z.string())]) }),\n    z.object({ feature: z.union([z.string(), z.array(z.string())]) }),\n    z.object({\n      device: z.union([deviceTypeSchema, z.array(deviceTypeSchema)]),\n    }),\n    LogicExpressionSchema,\n  ]);\n\n/**\n * Context for evaluating visibility\n */\nexport interface VisibilityContext {\n  dataModel: DataModel;\n  authState?: AuthState;\n  featureFlags?: FeatureFlags;\n  deviceState?: DeviceState;\n}\n\n/**\n * Evaluate a logic expression against data and auth state\n */\nexport function evaluateLogicExpression(\n  expr: LogicExpression,\n  ctx: VisibilityContext,\n): boolean {\n  const { dataModel } = ctx;\n\n  // AND expression\n  if (\"and\" in expr) {\n    return expr.and.every((subExpr) => evaluateLogicExpression(subExpr, ctx));\n  }\n\n  // OR expression\n  if (\"or\" in expr) {\n    return expr.or.some((subExpr) => evaluateLogicExpression(subExpr, ctx));\n  }\n\n  // NOT expression\n  if (\"not\" in expr) {\n    return !evaluateLogicExpression(expr.not, ctx);\n  }\n\n  // Path expression (resolve to boolean)\n  if (\"path\" in expr) {\n    const value = resolveDynamicValue({ path: expr.path }, dataModel);\n    return Boolean(value);\n  }\n\n  // Equality comparison\n  if (\"eq\" in expr) {\n    const [left, right] = expr.eq;\n    const leftValue = resolveDynamicValue(left, dataModel);\n    const rightValue = resolveDynamicValue(right, dataModel);\n    return leftValue === rightValue;\n  }\n\n  // Not equal comparison\n  if (\"neq\" in expr) {\n    const [left, right] = expr.neq;\n    const leftValue = resolveDynamicValue(left, dataModel);\n    const rightValue = resolveDynamicValue(right, dataModel);\n    return leftValue !== rightValue;\n  }\n\n  // Greater than\n  if (\"gt\" in expr) {\n    const [left, right] = expr.gt;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue > rightValue;\n    }\n    return false;\n  }\n\n  // Greater than or equal\n  if (\"gte\" in expr) {\n    const [left, right] = expr.gte;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue >= rightValue;\n    }\n    return false;\n  }\n\n  // Less than\n  if (\"lt\" in expr) {\n    const [left, right] = expr.lt;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue < rightValue;\n    }\n    return false;\n  }\n\n  // Less than or equal\n  if (\"lte\" in expr) {\n    const [left, right] = expr.lte;\n    const leftValue = resolveDynamicValue(\n      left as DynamicValue<number>,\n      dataModel,\n    );\n    const rightValue = resolveDynamicValue(\n      right as DynamicValue<number>,\n      dataModel,\n    );\n    if (typeof leftValue === \"number\" && typeof rightValue === \"number\") {\n      return leftValue <= rightValue;\n    }\n    return false;\n  }\n\n  return false;\n}\n\n/**\n * Evaluate a visibility condition\n */\nexport function evaluateVisibility(\n  condition: VisibilityCondition | undefined,\n  ctx: VisibilityContext,\n): boolean {\n  // No condition = visible\n  if (condition === undefined) {\n    return true;\n  }\n\n  // Boolean literal\n  if (typeof condition === \"boolean\") {\n    return condition;\n  }\n\n  // Path reference\n  if (\"path\" in condition && !(\"and\" in condition) && !(\"or\" in condition)) {\n    const value = resolveDynamicValue({ path: condition.path }, ctx.dataModel);\n    return Boolean(value);\n  }\n\n  // Auth condition\n  if (\"auth\" in condition) {\n    const isSignedIn = ctx.authState?.isSignedIn ?? false;\n    if (condition.auth === \"signedIn\") {\n      return isSignedIn;\n    }\n    if (condition.auth === \"signedOut\") {\n      return !isSignedIn;\n    }\n    return false;\n  }\n\n  // Role condition\n  if (\"role\" in condition) {\n    const userRoles = ctx.authState?.roles ?? [];\n    const requiredRoles = Array.isArray(condition.role)\n      ? condition.role\n      : [condition.role];\n    return requiredRoles.some((role) => userRoles.includes(role));\n  }\n\n  // Feature flag condition\n  if (\"feature\" in condition) {\n    const enabledFeatures = ctx.featureFlags?.enabled ?? [];\n    const requiredFeatures = Array.isArray(condition.feature)\n      ? condition.feature\n      : [condition.feature];\n    return requiredFeatures.some((f) => enabledFeatures.includes(f));\n  }\n\n  // Device condition\n  if (\"device\" in condition) {\n    const currentDevice = ctx.deviceState?.type ?? \"desktop\";\n    const allowedDevices = Array.isArray(condition.device)\n      ? condition.device\n      : [condition.device];\n    return allowedDevices.includes(currentDevice);\n  }\n\n  // Logic expression\n  return evaluateLogicExpression(condition as LogicExpression, ctx);\n}\n\n/**\n * Helper to create visibility conditions\n */\nexport const visibility = {\n  /** Always visible */\n  always: true as const,\n\n  /** Never visible */\n  never: false as const,\n\n  /** Visible when path is truthy */\n  when: (path: string): VisibilityCondition => ({ path }),\n\n  /** Visible when signed in */\n  signedIn: { auth: \"signedIn\" } as const,\n\n  /** Visible when signed out */\n  signedOut: { auth: \"signedOut\" } as const,\n\n  /** AND multiple conditions */\n  and: (...conditions: LogicExpression[]): LogicExpression => ({\n    and: conditions,\n  }),\n\n  /** OR multiple conditions */\n  or: (...conditions: LogicExpression[]): LogicExpression => ({\n    or: conditions,\n  }),\n\n  /** NOT a condition */\n  not: (condition: LogicExpression): LogicExpression => ({ not: condition }),\n\n  /** Equality check */\n  eq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\n    eq: [left, right],\n  }),\n\n  /** Not equal check */\n  neq: (left: DynamicValue, right: DynamicValue): LogicExpression => ({\n    neq: [left, right],\n  }),\n\n  /** Greater than */\n  gt: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ gt: [left, right] }),\n\n  /** Greater than or equal */\n  gte: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ gte: [left, right] }),\n\n  /** Less than */\n  lt: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ lt: [left, right] }),\n\n  /** Less than or equal */\n  lte: (\n    left: DynamicValue<number>,\n    right: DynamicValue<number>,\n  ): LogicExpression => ({ lte: [left, right] }),\n\n  /** Visible for specific roles */\n  hasRole: (role: string | string[]): VisibilityCondition => ({ role }),\n\n  /** Visible when feature flag is enabled */\n  hasFeature: (feature: string | string[]): VisibilityCondition => ({\n    feature,\n  }),\n\n  /** Visible on specific devices */\n  onDevice: (\n    device:\n      | \"mobile\"\n      | \"tablet\"\n      | \"desktop\"\n      | (\"mobile\" | \"tablet\" | \"desktop\")[],\n  ): VisibilityCondition => ({ device }),\n\n  /** Visible only on mobile */\n  mobileOnly: { device: \"mobile\" } as const,\n\n  /** Visible only on desktop */\n  desktopOnly: { device: \"desktop\" } as const,\n};\n","import { z } from \"zod\";\nimport type { DynamicValue, DataModel } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\n\n/**\n * Confirmation dialog configuration\n */\nexport interface ActionConfirm {\n  title: string;\n  message: string;\n  confirmLabel?: string;\n  cancelLabel?: string;\n  variant?: \"default\" | \"danger\";\n}\n\n/**\n * Action success handler\n */\nexport type ActionOnSuccess =\n  | { navigate: string }\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Action error handler\n */\nexport type ActionOnError =\n  | { set: Record<string, unknown> }\n  | { action: string };\n\n/**\n * Retry configuration for actions\n */\nexport interface ActionRetryConfig {\n  /** Maximum number of retry attempts */\n  maxAttempts: number;\n  /** Initial delay in ms between retries */\n  delayMs?: number;\n  /** Multiplier for exponential backoff */\n  backoffMultiplier?: number;\n  /** Maximum delay in ms */\n  maxDelayMs?: number;\n}\n\n/**\n * Optimistic update configuration\n */\nexport interface ActionOptimisticConfig {\n  /** Path to update optimistically */\n  path: string;\n  /** Value to set before action completes */\n  value: unknown;\n  /** Whether to revert on error (default: true) */\n  revertOnError?: boolean;\n}\n\n/**\n * Rich action definition\n */\nexport interface Action {\n  /** Action name (must be in catalog) */\n  name: string;\n  /** Parameters to pass to the action handler */\n  params?: Record<string, DynamicValue>;\n  /** Confirmation dialog before execution */\n  confirm?: ActionConfirm;\n  /** Handler after successful execution */\n  onSuccess?: ActionOnSuccess;\n  /** Handler after failed execution */\n  onError?: ActionOnError;\n  /** Throttle action execution (ms) - ignores calls during cooldown */\n  throttleMs?: number;\n  /** Debounce action execution (ms) - delays execution, resets on new calls */\n  debounceMs?: number;\n  /** Retry configuration for failed actions */\n  retry?: ActionRetryConfig;\n  /** Optimistic update configuration */\n  optimistic?: ActionOptimisticConfig;\n}\n\n/**\n * Schema for action confirmation\n */\nexport const ActionConfirmSchema = z.object({\n  title: z.string(),\n  message: z.string(),\n  confirmLabel: z.string().optional(),\n  cancelLabel: z.string().optional(),\n  variant: z.enum([\"default\", \"danger\"]).optional(),\n});\n\n/**\n * Schema for success handlers\n */\nexport const ActionOnSuccessSchema = z.union([\n  z.object({ navigate: z.string() }),\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Schema for error handlers\n */\nexport const ActionOnErrorSchema = z.union([\n  z.object({ set: z.record(z.string(), z.unknown()) }),\n  z.object({ action: z.string() }),\n]);\n\n/**\n * Schema for retry configuration\n */\nexport const ActionRetryConfigSchema = z.object({\n  maxAttempts: z.number().int().positive(),\n  delayMs: z.number().int().positive().optional(),\n  backoffMultiplier: z.number().positive().optional(),\n  maxDelayMs: z.number().int().positive().optional(),\n});\n\n/**\n * Schema for optimistic update configuration\n */\nexport const ActionOptimisticConfigSchema = z.object({\n  path: z.string(),\n  value: z.unknown(),\n  revertOnError: z.boolean().optional(),\n});\n\n/**\n * Full action schema\n */\nexport const ActionSchema = z.object({\n  name: z.string(),\n  params: z.record(z.string(), DynamicValueSchema).optional(),\n  confirm: ActionConfirmSchema.optional(),\n  onSuccess: ActionOnSuccessSchema.optional(),\n  onError: ActionOnErrorSchema.optional(),\n  throttleMs: z.number().int().positive().optional(),\n  debounceMs: z.number().int().positive().optional(),\n  retry: ActionRetryConfigSchema.optional(),\n  optimistic: ActionOptimisticConfigSchema.optional(),\n});\n\n/**\n * Action handler function signature\n */\nexport type ActionHandler<\n  TParams = Record<string, unknown>,\n  TResult = unknown,\n> = (params: TParams) => Promise<TResult> | TResult;\n\n/**\n * Action definition in catalog\n */\nexport interface ActionDefinition<TParams = Record<string, unknown>> {\n  /** Zod schema for params validation */\n  params?: z.ZodType<TParams>;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Resolved action with all dynamic values resolved\n */\nexport interface ResolvedAction {\n  name: string;\n  params: Record<string, unknown>;\n  confirm?: ActionConfirm;\n  onSuccess?: ActionOnSuccess;\n  onError?: ActionOnError;\n}\n\n/**\n * Resolve all dynamic values in an action\n */\nexport function resolveAction(\n  action: Action,\n  dataModel: DataModel,\n): ResolvedAction {\n  const resolvedParams: Record<string, unknown> = {};\n\n  if (action.params) {\n    for (const [key, value] of Object.entries(action.params)) {\n      resolvedParams[key] = resolveDynamicValue(value, dataModel);\n    }\n  }\n\n  // Interpolate confirmation message if present\n  let confirm = action.confirm;\n  if (confirm) {\n    confirm = {\n      ...confirm,\n      message: interpolateString(confirm.message, dataModel),\n      title: interpolateString(confirm.title, dataModel),\n    };\n  }\n\n  return {\n    name: action.name,\n    params: resolvedParams,\n    confirm,\n    onSuccess: action.onSuccess,\n    onError: action.onError,\n  };\n}\n\n/**\n * Interpolate ${path} expressions in a string\n */\nexport function interpolateString(\n  template: string,\n  dataModel: DataModel,\n): string {\n  return template.replace(/\\$\\{([^}]+)\\}/g, (_, path) => {\n    const value = resolveDynamicValue({ path }, dataModel);\n    return String(value ?? \"\");\n  });\n}\n\n/**\n * Context for action execution\n */\nexport interface ActionExecutionContext {\n  /** The resolved action */\n  action: ResolvedAction;\n  /** The action handler from the host */\n  handler: ActionHandler;\n  /** Function to update data model */\n  setData: (path: string, value: unknown) => void;\n  /** Function to navigate */\n  navigate?: (path: string) => void;\n  /** Function to execute another action */\n  executeAction?: (name: string) => Promise<void>;\n}\n\n/**\n * Execute an action with all callbacks\n */\nexport async function executeAction(\n  ctx: ActionExecutionContext,\n): Promise<void> {\n  const { action, handler, setData, navigate, executeAction } = ctx;\n\n  try {\n    await handler(action.params);\n\n    // Handle success\n    if (action.onSuccess) {\n      if (\"navigate\" in action.onSuccess && navigate) {\n        navigate(action.onSuccess.navigate);\n      } else if (\"set\" in action.onSuccess) {\n        for (const [path, value] of Object.entries(action.onSuccess.set)) {\n          setData(path, value);\n        }\n      } else if (\"action\" in action.onSuccess && executeAction) {\n        await executeAction(action.onSuccess.action);\n      }\n    }\n  } catch (error) {\n    // Handle error\n    if (action.onError) {\n      if (\"set\" in action.onError) {\n        for (const [path, value] of Object.entries(action.onError.set)) {\n          // Replace $error.message with actual error\n          const resolvedValue =\n            typeof value === \"string\" && value === \"$error.message\"\n              ? (error as Error).message\n              : value;\n          setData(path, resolvedValue);\n        }\n      } else if (\"action\" in action.onError && executeAction) {\n        await executeAction(action.onError.action);\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Helper to create actions\n */\nexport const action = {\n  /** Create a simple action */\n  simple: (name: string, params?: Record<string, DynamicValue>): Action => ({\n    name,\n    params,\n  }),\n\n  /** Create an action with confirmation */\n  withConfirm: (\n    name: string,\n    confirm: ActionConfirm,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    confirm,\n  }),\n\n  /** Create an action with success handler */\n  withSuccess: (\n    name: string,\n    onSuccess: ActionOnSuccess,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    onSuccess,\n  }),\n\n  /** Create a throttled action (ignores calls during cooldown) */\n  throttled: (\n    name: string,\n    throttleMs: number,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    throttleMs,\n  }),\n\n  /** Create a debounced action (delays execution, resets on new calls) */\n  debounced: (\n    name: string,\n    debounceMs: number,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    debounceMs,\n  }),\n\n  /** Create an action with retry */\n  withRetry: (\n    name: string,\n    retry: ActionRetryConfig,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    retry,\n  }),\n\n  /** Create an action with optimistic update */\n  optimistic: (\n    name: string,\n    optimistic: ActionOptimisticConfig,\n    params?: Record<string, DynamicValue>,\n  ): Action => ({\n    name,\n    params,\n    optimistic,\n  }),\n};\n","import { z } from \"zod\";\nimport type { DynamicValue, DataModel, LogicExpression } from \"./types\";\nimport { DynamicValueSchema, resolveDynamicValue } from \"./types\";\nimport {\n  LogicExpressionSchema,\n  evaluateLogicExpression,\n  type VisibilityContext,\n} from \"./visibility\";\n\n/**\n * Validation check definition\n */\nexport interface ValidationCheck {\n  /** Function name (built-in or from catalog) */\n  fn: string;\n  /** Additional arguments for the function */\n  args?: Record<string, DynamicValue>;\n  /** Error message to display if check fails */\n  message: string;\n  /** Condition for when this check should run */\n  when?: LogicExpression;\n}\n\n/**\n * Validation configuration for a field\n */\nexport interface ValidationConfig {\n  /** Array of checks to run */\n  checks?: ValidationCheck[];\n  /** When to run validation */\n  validateOn?: \"change\" | \"blur\" | \"submit\";\n  /** Condition for when validation is enabled */\n  enabled?: LogicExpression;\n}\n\n/**\n * Schema for validation check\n */\nexport const ValidationCheckSchema = z.object({\n  fn: z.string(),\n  args: z.record(z.string(), DynamicValueSchema).optional(),\n  message: z.string(),\n  when: LogicExpressionSchema.optional(),\n});\n\n/**\n * Schema for validation config\n */\nexport const ValidationConfigSchema = z.object({\n  checks: z.array(ValidationCheckSchema).optional(),\n  validateOn: z.enum([\"change\", \"blur\", \"submit\"]).optional(),\n  enabled: LogicExpressionSchema.optional(),\n});\n\n/**\n * Validation function signature\n */\nexport type ValidationFunction = (\n  value: unknown,\n  args?: Record<string, unknown>,\n) => boolean;\n\n/**\n * Validation function definition in catalog\n */\nexport interface ValidationFunctionDefinition {\n  /** The validation function */\n  validate: ValidationFunction;\n  /** Description for AI */\n  description?: string;\n}\n\n/**\n * Built-in validation functions\n */\nexport const builtInValidationFunctions: Record<string, ValidationFunction> = {\n  /**\n   * Check if value is not null, undefined, or empty string\n   */\n  required: (value: unknown) => {\n    if (value === null || value === undefined) return false;\n    if (typeof value === \"string\") return value.trim().length > 0;\n    if (Array.isArray(value)) return value.length > 0;\n    return true;\n  },\n\n  /**\n   * Check if value is a valid email address\n   */\n  email: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\n  },\n\n  /**\n   * Check minimum string length\n   */\n  minLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value.length >= min;\n  },\n\n  /**\n   * Check maximum string length\n   */\n  maxLength: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value.length <= max;\n  },\n\n  /**\n   * Check if string matches a regex pattern\n   */\n  pattern: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const pattern = args?.pattern;\n    if (typeof pattern !== \"string\") return false;\n    try {\n      return new RegExp(pattern).test(value);\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check minimum numeric value\n   */\n  min: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value >= min;\n  },\n\n  /**\n   * Check maximum numeric value\n   */\n  max: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"number\") return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value <= max;\n  },\n\n  /**\n   * Check if value is a number\n   */\n  numeric: (value: unknown) => {\n    if (typeof value === \"number\") return !isNaN(value);\n    if (typeof value === \"string\") return !isNaN(parseFloat(value));\n    return false;\n  },\n\n  /**\n   * Check if value is a valid URL\n   */\n  url: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    try {\n      new URL(value);\n      return true;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Check if value matches another field\n   */\n  matches: (value: unknown, args?: Record<string, unknown>) => {\n    const other = args?.other;\n    return value === other;\n  },\n\n  /**\n   * Check if value is a valid phone number (international format)\n   */\n  phone: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    // Matches international phone formats: +1234567890, (123) 456-7890, etc.\n    const phoneRegex = /^[+]?[(]?[0-9]{1,4}[)]?[-\\s./0-9]*$/;\n    return phoneRegex.test(value) && value.replace(/\\D/g, \"\").length >= 7;\n  },\n\n  /**\n   * Check if value is a valid date string\n   */\n  date: (value: unknown, args?: Record<string, unknown>) => {\n    if (typeof value !== \"string\") return false;\n    const date = new Date(value);\n    if (isNaN(date.getTime())) return false;\n\n    // Optional: check format\n    const format = args?.format as string | undefined;\n    if (format === \"iso\") {\n      return /^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}:\\d{2})?/.test(value);\n    }\n\n    return true;\n  },\n\n  /**\n   * Check if date is in the future\n   */\n  futureDate: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    const date = new Date(value);\n    if (isNaN(date.getTime())) return false;\n    return date > new Date();\n  },\n\n  /**\n   * Check if date is in the past\n   */\n  pastDate: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    const date = new Date(value);\n    if (isNaN(date.getTime())) return false;\n    return date < new Date();\n  },\n\n  /**\n   * Check if value contains only alphanumeric characters\n   */\n  alphanumeric: (value: unknown) => {\n    if (typeof value !== \"string\") return false;\n    return /^[a-zA-Z0-9]+$/.test(value);\n  },\n\n  /**\n   * Check if array has at least N items\n   */\n  minItems: (value: unknown, args?: Record<string, unknown>) => {\n    if (!Array.isArray(value)) return false;\n    const min = args?.min;\n    if (typeof min !== \"number\") return false;\n    return value.length >= min;\n  },\n\n  /**\n   * Check if array has at most N items\n   */\n  maxItems: (value: unknown, args?: Record<string, unknown>) => {\n    if (!Array.isArray(value)) return false;\n    const max = args?.max;\n    if (typeof max !== \"number\") return false;\n    return value.length <= max;\n  },\n};\n\n/**\n * Validation result for a single check\n */\nexport interface ValidationCheckResult {\n  fn: string;\n  valid: boolean;\n  message: string;\n}\n\n/**\n * Full validation result for a field\n */\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  checks: ValidationCheckResult[];\n}\n\n/**\n * Context for running validation\n */\nexport interface ValidationContext {\n  /** Current value to validate */\n  value: unknown;\n  /** Full data model for resolving paths */\n  dataModel: DataModel;\n  /** Custom validation functions from catalog */\n  customFunctions?: Record<string, ValidationFunction>;\n}\n\n/**\n * Run a single validation check\n */\nexport function runValidationCheck(\n  check: ValidationCheck,\n  ctx: ValidationContext,\n): ValidationCheckResult {\n  const { value, dataModel, customFunctions } = ctx;\n\n  // Check if this validation check should run (when condition)\n  if (check.when) {\n    const visibilityCtx: VisibilityContext = { dataModel };\n    const shouldRun = evaluateLogicExpression(check.when, visibilityCtx);\n    if (!shouldRun) {\n      return {\n        fn: check.fn,\n        valid: true, // Skip this check when condition is false\n        message: check.message,\n      };\n    }\n  }\n\n  // Resolve args\n  const resolvedArgs: Record<string, unknown> = {};\n  if (check.args) {\n    for (const [key, argValue] of Object.entries(check.args)) {\n      resolvedArgs[key] = resolveDynamicValue(argValue, dataModel);\n    }\n  }\n\n  // Find the validation function\n  const fn =\n    builtInValidationFunctions[check.fn] ?? customFunctions?.[check.fn];\n\n  if (!fn) {\n    console.warn(`Unknown validation function: ${check.fn}`);\n    return {\n      fn: check.fn,\n      valid: true, // Don't fail on unknown functions\n      message: check.message,\n    };\n  }\n\n  const valid = fn(value, resolvedArgs);\n\n  return {\n    fn: check.fn,\n    valid,\n    message: check.message,\n  };\n}\n\n/**\n * Run all validation checks for a field\n */\nexport function runValidation(\n  config: ValidationConfig,\n  ctx: ValidationContext & { authState?: { isSignedIn: boolean } },\n): ValidationResult {\n  const checks: ValidationCheckResult[] = [];\n  const errors: string[] = [];\n\n  // Check if validation is enabled\n  if (config.enabled) {\n    const enabled = evaluateLogicExpression(config.enabled, {\n      dataModel: ctx.dataModel,\n      authState: ctx.authState,\n    });\n    if (!enabled) {\n      return { valid: true, errors: [], checks: [] };\n    }\n  }\n\n  // Run each check\n  if (config.checks) {\n    for (const check of config.checks) {\n      const result = runValidationCheck(check, ctx);\n      checks.push(result);\n      if (!result.valid) {\n        errors.push(result.message);\n      }\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    checks,\n  };\n}\n\n/**\n * Helper to create validation checks\n */\nexport const check = {\n  required: (message = \"This field is required\"): ValidationCheck => ({\n    fn: \"required\",\n    message,\n  }),\n\n  email: (message = \"Invalid email address\"): ValidationCheck => ({\n    fn: \"email\",\n    message,\n  }),\n\n  minLength: (min: number, message?: string): ValidationCheck => ({\n    fn: \"minLength\",\n    args: { min },\n    message: message ?? `Must be at least ${min} characters`,\n  }),\n\n  maxLength: (max: number, message?: string): ValidationCheck => ({\n    fn: \"maxLength\",\n    args: { max },\n    message: message ?? `Must be at most ${max} characters`,\n  }),\n\n  pattern: (pattern: string, message = \"Invalid format\"): ValidationCheck => ({\n    fn: \"pattern\",\n    args: { pattern },\n    message,\n  }),\n\n  min: (min: number, message?: string): ValidationCheck => ({\n    fn: \"min\",\n    args: { min },\n    message: message ?? `Must be at least ${min}`,\n  }),\n\n  max: (max: number, message?: string): ValidationCheck => ({\n    fn: \"max\",\n    args: { max },\n    message: message ?? `Must be at most ${max}`,\n  }),\n\n  url: (message = \"Invalid URL\"): ValidationCheck => ({\n    fn: \"url\",\n    message,\n  }),\n\n  matches: (\n    otherPath: string,\n    message = \"Fields must match\",\n  ): ValidationCheck => ({\n    fn: \"matches\",\n    args: { other: { path: otherPath } },\n    message,\n  }),\n\n  phone: (message = \"Invalid phone number\"): ValidationCheck => ({\n    fn: \"phone\",\n    message,\n  }),\n\n  date: (message = \"Invalid date\"): ValidationCheck => ({\n    fn: \"date\",\n    message,\n  }),\n\n  isoDate: (message = \"Must be ISO date format\"): ValidationCheck => ({\n    fn: \"date\",\n    args: { format: \"iso\" },\n    message,\n  }),\n\n  futureDate: (message = \"Must be a future date\"): ValidationCheck => ({\n    fn: \"futureDate\",\n    message,\n  }),\n\n  pastDate: (message = \"Must be a past date\"): ValidationCheck => ({\n    fn: \"pastDate\",\n    message,\n  }),\n\n  alphanumeric: (\n    message = \"Must contain only letters and numbers\",\n  ): ValidationCheck => ({\n    fn: \"alphanumeric\",\n    message,\n  }),\n\n  minItems: (min: number, message?: string): ValidationCheck => ({\n    fn: \"minItems\",\n    args: { min },\n    message: message ?? `Must have at least ${min} items`,\n  }),\n\n  maxItems: (max: number, message?: string): ValidationCheck => ({\n    fn: \"maxItems\",\n    args: { max },\n    message: message ?? `Must have at most ${max} items`,\n  }),\n\n  /** Create a conditional check (only runs when condition is true) */\n  when: (\n    condition: LogicExpression,\n    check: ValidationCheck,\n  ): ValidationCheck => ({\n    ...check,\n    when: condition,\n  }),\n};\n","import { z } from \"zod\";\nimport type {\n  ComponentSchema,\n  ValidationMode,\n  UIElement,\n  UITree,\n  VisibilityCondition,\n} from \"./types\";\nimport { VisibilityConditionSchema } from \"./visibility\";\nimport { ActionSchema, type ActionDefinition } from \"./actions\";\nimport { ValidationConfigSchema, type ValidationFunction } from \"./validation\";\n\n/**\n * Component definition with visibility and validation support\n */\nexport interface ComponentDefinition<\n  TProps extends ComponentSchema = ComponentSchema,\n> {\n  /** Zod schema for component props */\n  props: TProps;\n  /** Whether this component can have children */\n  hasChildren?: boolean;\n  /** Description for AI generation */\n  description?: string;\n}\n\n/**\n * Catalog configuration\n */\nexport interface CatalogConfig<\n  TComponents extends Record<string, ComponentDefinition> = Record<\n    string,\n    ComponentDefinition\n  >,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  name?: string;\n  /** Component definitions */\n  components: TComponents;\n  /** Action definitions with param schemas */\n  actions?: TActions;\n  /** Custom validation functions */\n  functions?: TFunctions;\n  /** Validation mode */\n  validation?: ValidationMode;\n}\n\n/**\n * Catalog instance\n */\nexport interface Catalog<\n  TComponents extends Record<string, ComponentDefinition> = Record<\n    string,\n    ComponentDefinition\n  >,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  readonly name: string;\n  /** Component names */\n  readonly componentNames: (keyof TComponents)[];\n  /** Action names */\n  readonly actionNames: (keyof TActions)[];\n  /** Function names */\n  readonly functionNames: (keyof TFunctions)[];\n  /** Validation mode */\n  readonly validation: ValidationMode;\n  /** Component definitions */\n  readonly components: TComponents;\n  /** Action definitions */\n  readonly actions: TActions;\n  /** Custom validation functions */\n  readonly functions: TFunctions;\n  /** Full element schema for AI generation */\n  readonly elementSchema: z.ZodType<UIElement>;\n  /** Full UI tree schema */\n  readonly treeSchema: z.ZodType<UITree>;\n  /** Check if component exists */\n  hasComponent(type: string): boolean;\n  /** Check if action exists */\n  hasAction(name: string): boolean;\n  /** Check if function exists */\n  hasFunction(name: string): boolean;\n  /** Validate an element */\n  validateElement(element: unknown): {\n    success: boolean;\n    data?: UIElement;\n    error?: z.ZodError;\n  };\n  /** Validate a UI tree */\n  validateTree(tree: unknown): {\n    success: boolean;\n    data?: UITree;\n    error?: z.ZodError;\n  };\n}\n\n/**\n * Create a v2 catalog with visibility, actions, and validation support\n */\nexport function createCatalog<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n>(\n  config: CatalogConfig<TComponents, TActions, TFunctions>,\n): Catalog<TComponents, TActions, TFunctions> {\n  const {\n    name = \"unnamed\",\n    components,\n    actions = {} as TActions,\n    functions = {} as TFunctions,\n    validation = \"strict\",\n  } = config;\n\n  const componentNames = Object.keys(components) as (keyof TComponents)[];\n  const actionNames = Object.keys(actions) as (keyof TActions)[];\n  const functionNames = Object.keys(functions) as (keyof TFunctions)[];\n\n  // Create element schema for each component type\n  const componentSchemas = componentNames.map((componentName) => {\n    const def = components[componentName]!;\n\n    return z.object({\n      key: z.string(),\n      type: z.literal(componentName as string),\n      props: def.props,\n      children: z.array(z.string()).optional(),\n      parentKey: z.string().nullable().optional(),\n      visible: VisibilityConditionSchema.optional(),\n    });\n  });\n\n  // Create union schema for all components\n  let elementSchema: z.ZodType<UIElement>;\n\n  if (componentSchemas.length === 0) {\n    elementSchema = z.object({\n      key: z.string(),\n      type: z.string(),\n      props: z.record(z.string(), z.unknown()),\n      children: z.array(z.string()).optional(),\n      parentKey: z.string().nullable().optional(),\n      visible: VisibilityConditionSchema.optional(),\n    }) as unknown as z.ZodType<UIElement>;\n  } else if (componentSchemas.length === 1) {\n    elementSchema = componentSchemas[0] as unknown as z.ZodType<UIElement>;\n  } else {\n    elementSchema = z.discriminatedUnion(\"type\", [\n      componentSchemas[0] as z.ZodObject<any>,\n      componentSchemas[1] as z.ZodObject<any>,\n      ...(componentSchemas.slice(2) as z.ZodObject<any>[]),\n    ]) as unknown as z.ZodType<UIElement>;\n  }\n\n  // Create tree schema\n  const treeSchema = z.object({\n    root: z.string(),\n    elements: z.record(z.string(), elementSchema),\n  }) as unknown as z.ZodType<UITree>;\n\n  return {\n    name,\n    componentNames,\n    actionNames,\n    functionNames,\n    validation,\n    components,\n    actions,\n    functions,\n    elementSchema,\n    treeSchema,\n\n    hasComponent(type: string) {\n      return type in components;\n    },\n\n    hasAction(name: string) {\n      return name in actions;\n    },\n\n    hasFunction(name: string) {\n      return name in functions;\n    },\n\n    validateElement(element: unknown) {\n      const result = elementSchema.safeParse(element);\n      if (result.success) {\n        return { success: true, data: result.data };\n      }\n      return { success: false, error: result.error };\n    },\n\n    validateTree(tree: unknown) {\n      const result = treeSchema.safeParse(tree);\n      if (result.success) {\n        return { success: true, data: result.data };\n      }\n      return { success: false, error: result.error };\n    },\n  };\n}\n\n/**\n * Generate a prompt for AI that describes the catalog\n */\nexport function generateCatalogPrompt<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition>,\n  TFunctions extends Record<string, ValidationFunction>,\n>(catalog: Catalog<TComponents, TActions, TFunctions>): string {\n  const lines: string[] = [\n    `# ${catalog.name} Component Catalog`,\n    \"\",\n    \"## Available Components\",\n    \"\",\n  ];\n\n  // Components\n  for (const name of catalog.componentNames) {\n    const def = catalog.components[name]!;\n    lines.push(`### ${String(name)}`);\n    if (def.description) {\n      lines.push(def.description);\n    }\n    lines.push(\"\");\n  }\n\n  // Actions\n  if (catalog.actionNames.length > 0) {\n    lines.push(\"## Available Actions\");\n    lines.push(\"\");\n    for (const name of catalog.actionNames) {\n      const def = catalog.actions[name]!;\n      lines.push(\n        `- \\`${String(name)}\\`${def.description ? `: ${def.description}` : \"\"}`,\n      );\n    }\n    lines.push(\"\");\n  }\n\n  // Visibility\n  lines.push(\"## Visibility Conditions\");\n  lines.push(\"\");\n  lines.push(\"Components can have a `visible` property:\");\n  lines.push(\"- `true` / `false` - Always visible/hidden\");\n  lines.push('- `{ \"path\": \"/data/path\" }` - Visible when path is truthy');\n  lines.push('- `{ \"auth\": \"signedIn\" }` - Visible when user is signed in');\n  lines.push('- `{ \"and\": [...] }` - All conditions must be true');\n  lines.push('- `{ \"or\": [...] }` - Any condition must be true');\n  lines.push('- `{ \"not\": {...} }` - Negates a condition');\n  lines.push('- `{ \"eq\": [a, b] }` - Equality check');\n  lines.push(\"\");\n\n  // Validation\n  lines.push(\"## Validation Functions\");\n  lines.push(\"\");\n  lines.push(\n    \"Built-in: `required`, `email`, `minLength`, `maxLength`, `pattern`, `min`, `max`, `url`\",\n  );\n  if (catalog.functionNames.length > 0) {\n    lines.push(`Custom: ${catalog.functionNames.map(String).join(\", \")}`);\n  }\n  lines.push(\"\");\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Type helper to infer component props from catalog\n */\nexport type InferCatalogComponentProps<\n  C extends Catalog<Record<string, ComponentDefinition>>,\n> = {\n  [K in keyof C[\"components\"]]: z.infer<C[\"components\"][K][\"props\"]>;\n};\n","import { z } from \"zod\";\nimport type { ComponentSchema, ValidationMode } from \"./types\";\nimport type { ComponentDefinition, Catalog, CatalogConfig } from \"./catalog\";\nimport { createCatalog } from \"./catalog\";\nimport type { ActionDefinition } from \"./actions\";\nimport type { ValidationFunction } from \"./validation\";\n\n/**\n * Configuration for defineComponent\n */\nexport interface DefineComponentConfig<\n  TName extends string,\n  TProps extends ComponentSchema,\n> {\n  /** Unique component name */\n  name: TName;\n  /** Zod schema for component props */\n  props: TProps;\n  /** Description for AI generation and documentation */\n  description: string;\n  /** Whether this component can have children */\n  hasChildren?: boolean;\n  /** Category for organization (e.g., \"layout\", \"data-display\") */\n  category?: string;\n  /** AI generation hints and rules */\n  aiHints?: string[];\n}\n\n/**\n * Component definition with full type inference\n */\nexport interface TypedComponentDefinition<\n  TName extends string = string,\n  TProps extends ComponentSchema = ComponentSchema,\n> extends ComponentDefinition<TProps> {\n  /** Component name with literal type */\n  readonly name: TName;\n  /** Props schema */\n  readonly props: TProps;\n  /** Description */\n  readonly description: string;\n  /** Has children */\n  readonly hasChildren: boolean;\n  /** Category */\n  readonly category?: string;\n  /** AI hints */\n  readonly aiHints?: string[];\n}\n\n/**\n * Define a component with full type inference and validation.\n *\n * @example\n * ```ts\n * const CardDefinition = defineComponent({\n *   name: \"Card\",\n *   props: z.object({\n *     title: z.string().optional(),\n *     padding: z.enum([\"sm\", \"md\", \"lg\"]).default(\"md\"),\n *   }),\n *   description: \"A card container with optional title\",\n *   hasChildren: true,\n *   category: \"layout\",\n * });\n *\n * // Type-safe props inference\n * type CardProps = InferComponentProps<typeof CardDefinition>;\n * ```\n */\nexport function defineComponent<\n  TName extends string,\n  TProps extends ComponentSchema,\n>(\n  config: DefineComponentConfig<TName, TProps>,\n): TypedComponentDefinition<TName, TProps> {\n  const {\n    name,\n    props,\n    description,\n    hasChildren = false,\n    category,\n    aiHints,\n  } = config;\n\n  return {\n    name,\n    props,\n    description,\n    hasChildren,\n    category,\n    aiHints,\n  };\n}\n\n/**\n * Infer props type from a component definition\n */\nexport type InferComponentProps<T extends TypedComponentDefinition> = z.infer<\n  T[\"props\"]\n>;\n\n/**\n * Infer component name from a component definition\n */\nexport type InferComponentName<T extends TypedComponentDefinition> = T[\"name\"];\n\n/**\n * Convert a typed component definition to a catalog-compatible format\n */\nexport function toCatalogDefinition<T extends TypedComponentDefinition>(\n  definition: T,\n): ComponentDefinition<T[\"props\"]> {\n  return {\n    props: definition.props,\n    description: definition.description,\n    hasChildren: definition.hasChildren,\n  };\n}\n\n/**\n * Convert multiple typed component definitions to catalog-compatible format\n */\nexport function toCatalogDefinitions<\n  T extends Record<string, TypedComponentDefinition>,\n>(definitions: T): { [K in keyof T]: ComponentDefinition<T[K][\"props\"]> } {\n  const result = {} as { [K in keyof T]: ComponentDefinition<T[K][\"props\"]> };\n\n  for (const key of Object.keys(definitions)) {\n    const def = definitions[key];\n    if (def) {\n      result[key as keyof T] = {\n        props: def.props,\n        description: def.description,\n        hasChildren: def.hasChildren,\n      };\n    }\n  }\n\n  return result;\n}\n\n/**\n * Options for createCatalogFromComponents\n */\nexport interface CreateCatalogFromComponentsOptions<\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n> {\n  /** Catalog name */\n  name?: string;\n  /** Action definitions */\n  actions?: TActions;\n  /** Custom validation functions */\n  functions?: TFunctions;\n  /** Validation mode: \"strict\" | \"warn\" | \"ignore\" */\n  validation?: ValidationMode;\n}\n\n/**\n * Create a catalog directly from typed component definitions.\n * This is a convenience function that combines toCatalogDefinitions + createCatalog.\n *\n * @example\n * ```ts\n * import { CardDefinition, MetricDefinition } from \"@onegenui/components\";\n *\n * const catalog = createCatalogFromComponents(\n *   { Card: CardDefinition, Metric: MetricDefinition },\n *   { name: \"my-catalog\" }\n * );\n * ```\n */\nexport function createCatalogFromComponents<\n  T extends Record<string, TypedComponentDefinition>,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n>(\n  definitions: T,\n  options: CreateCatalogFromComponentsOptions<TActions, TFunctions> = {},\n): Catalog<\n  { [K in keyof T]: ComponentDefinition<T[K][\"props\"]> },\n  TActions,\n  TFunctions\n> {\n  const catalogDefinitions = toCatalogDefinitions(definitions);\n\n  const config: CatalogConfig<\n    { [K in keyof T]: ComponentDefinition<T[K][\"props\"]> },\n    TActions,\n    TFunctions\n  > = {\n    name: options.name,\n    components: catalogDefinitions,\n    actions: options.actions,\n    functions: options.functions,\n    validation: options.validation,\n  };\n\n  return createCatalog(config);\n}\n","/**\n * Schema description utilities for Zod schemas\n * Extracts human-readable descriptions for AI prompt generation\n */\n\n/**\n * Extract a human-readable description of a Zod schema\n * Uses duck typing to handle different Zod versions\n */\nexport function describeZodSchema(schema: unknown): string {\n  const s = schema as Record<string, unknown>;\n\n  // Handle ZodObject - check for 'shape' property\n  if (s && typeof s === \"object\" && \"shape\" in s && s.shape) {\n    const shape = s.shape as Record<string, unknown>;\n    const parts: string[] = [];\n\n    for (const [key, value] of Object.entries(shape)) {\n      parts.push(`${key}: ${describeZodType(value)}`);\n    }\n\n    return `{ ${parts.join(\", \")} }`;\n  }\n\n  return describeZodType(schema);\n}\n\n/**\n * Describe a Zod type in a human-readable way\n * Uses duck typing to be compatible with different Zod versions\n */\nexport function describeZodType(schema: unknown): string {\n  if (!schema || typeof schema !== \"object\") return \"unknown\";\n\n  const s = schema as Record<string, unknown>;\n  const typeName = s._def\n    ? (s._def as Record<string, unknown>).typeName\n    : undefined;\n\n  // Handle optional - has innerType in _def\n  if (typeName === \"ZodOptional\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    return `${describeZodType(def.innerType)}?`;\n  }\n\n  // Handle nullable\n  if (typeName === \"ZodNullable\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    return `${describeZodType(def.innerType)} | null`;\n  }\n\n  // Handle defaults\n  if (typeName === \"ZodDefault\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    return describeZodType(def.innerType);\n  }\n\n  // Handle primitives\n  if (typeName === \"ZodString\") return \"string\";\n  if (typeName === \"ZodNumber\") return \"number\";\n  if (typeName === \"ZodBoolean\") return \"boolean\";\n\n  // Handle enums\n  if (typeName === \"ZodEnum\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    const values = def.values as string[];\n    if (Array.isArray(values)) {\n      return values.map((v) => `\"${v}\"`).join(\" | \");\n    }\n  }\n\n  // Handle literals\n  if (typeName === \"ZodLiteral\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    const value = def.value;\n    return typeof value === \"string\" ? `\"${value}\"` : String(value);\n  }\n\n  // Handle unions\n  if (typeName === \"ZodUnion\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    const options = def.options as unknown[];\n    if (Array.isArray(options)) {\n      return options.map(describeZodType).join(\" | \");\n    }\n  }\n\n  // Handle arrays\n  if (typeName === \"ZodArray\" && s._def) {\n    const def = s._def as Record<string, unknown>;\n    const elementType = describeZodType(def.type);\n    return `[${elementType}]`;\n  }\n\n  // Handle objects (nested)\n  if (typeName === \"ZodObject\" || (\"shape\" in s && s.shape)) {\n    return describeZodSchema(schema);\n  }\n\n  return \"unknown\";\n}\n","/**\n * Rules generators for AI prompt sections\n * Single Responsibility: Each function generates one specific rule section\n */\n\n/**\n * Generate the streaming strategy section\n */\nexport function generateStreamingStrategy(): string {\n  return `\nSTREAMING STRATEGY:\n1. Create containers (Stack, Grid, Card) with children:[] EMPTY\n2. Add each child element as a separate operation\n3. Append child key to parent via: {\"op\":\"add\",\"path\":\"/elements/PARENT/children/-\",\"value\":\"CHILD_KEY\"}\n4. For data props (items, rows, documents), use \"replace\" to set full content after element creation\n5. Prefer multiple small patches for responsive UI updates\n6. Use short, descriptive keys (e.g., \"revenue-metric\", \"user-table\")\n\nNEVER DO THIS (pre-populated children):\n{\"op\":\"add\",\"path\":\"/elements/grid\",\"value\":{\"key\":\"grid\",\"type\":\"Grid\",\"children\":[\"a\",\"b\",\"c\"]}}\n\nALWAYS DO THIS (empty children, then append):\n{\"op\":\"add\",\"path\":\"/elements/grid\",\"value\":{\"key\":\"grid\",\"type\":\"Grid\",\"children\":[]}}\n{\"op\":\"add\",\"path\":\"/elements/a\",\"value\":{...}}\n{\"op\":\"add\",\"path\":\"/elements/grid/children/-\",\"value\":\"a\"}`;\n}\n\n/**\n * Generate layout rules section\n */\nexport function generateLayoutRules(): string {\n  return `\nLAYOUT RULES:\n- ALWAYS use Stack or Grid as root container when generating multiple components\n- Stack: Set gap prop for vertical spacing (e.g., \"gap\": \"lg\" or \"gap\": \"md\")\n- Grid: Set gap prop for both row/column spacing\n- Available gap values: \"none\", \"xs\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\"\n- RECOMMENDED: Use \"gap\": \"lg\" for main layouts, \"gap\": \"md\" for nested content\n- Single components may omit container, but prefer Card wrapper for visual consistency`;\n}\n\n/**\n * Generate the message rules section\n */\nexport function generateMessageRules(): string {\n  return `\nMESSAGE RULES:\n- ALWAYS begin your response with a 'message' operation to explain what you are building.\n- Use 'message' operations to provide context, ask for feedback, or explain design decisions.\n- Do NOT treat messages and UI patches as mutually exclusive; use BOTH.\n- Example:\n  {\"op\":\"message\",\"role\":\"assistant\",\"content\":\"I'm creating a dashboard with charts and metrics.\"}\n  {\"op\":\"set\",\"path\":\"/root\",\"value\":\"dashboard\"}\n\nMESSAGE CONTENT RULES:\n- Messages should be CONVERSATIONAL and HELPFUL\n- Messages provide context, reasoning, and high-level summaries\n- NEVER include URLs, links, or deep links in messages - put them in component props instead\n- NEVER include raw JSON, JSONL operations, or technical code in messages\n- NEVER include markdown tables or data dumps - use UI components to display structured data\n- NEVER echo back the JSONL patches as text - the user sees the rendered components\n- If a component has a prop for links (e.g., bookingUrl, href, url), use THAT prop, not the message`;\n}\n\n/**\n * Generate the selection context rules section\n */\nexport function generateSelectionRules(): string {\n  return `\nSELECTION CONTEXT BEHAVIOR:\n\nWhen SELECTED ELEMENT CONTEXT is present in the prompt, you must reason about what the user wants.\n\nREASONING PROCESS:\n1. Read the user's request carefully - understand the semantic meaning\n2. Examine the selected element - its type, current content, structure, purpose\n3. Think: \"What would best serve the user given this element and this request?\"\n4. Decide your approach based on your reasoning\n\nYou have FULL AUTONOMY to:\n- MODIFY the selected element (change props, update content, fix issues)\n- ADD new content (siblings, children, or related components)  \n- DO BOTH if the request naturally calls for it\n\nThere are NO rigid keyword rules. Each situation is unique. Use your understanding of:\n- What the element currently contains\n- What the user is trying to achieve  \n- What would create the best user experience`;\n}\n\n/**\n * Generate the base JSONL output format rules\n */\nexport function generateOutputFormat(): string {\n  return `\nOUTPUT FORMAT:\nOutput JSONL where each line is a patch operation. Use a FLAT key-based structure:\n\nOPERATIONS:\n- {\"op\":\"set\",\"path\":\"/root\",\"value\":\"main-stack\"} - Set the root element key\n- {\"op\":\"add\",\"path\":\"/elements/main-stack\",\"value\":{...}} - Add an element by unique key\n- {\"op\":\"add\",\"path\":\"/elements/parent/children/-\",\"value\":\"child-key\"} - Append child to parent\n- {\"op\":\"replace\",\"path\":\"/elements/key/props/data\",\"value\":[...]} - Update element data\n- {\"op\":\"message\",\"role\":\"assistant\",\"content\":\"...\"} - Send a conversational message\n\nELEMENT STRUCTURE:\n{\n  \"key\": \"unique-key\",\n  \"type\": \"ComponentType\",\n  \"props\": { ... },\n  \"children\": []  // Start empty, add children via /children/- operations\n}\n\nCRITICAL STREAMING ORDER:\n1. FIRST: {\"op\":\"message\"} - Explain what you're building\n2. SECOND: {\"op\":\"set\",\"path\":\"/root\",\"value\":\"root-key\"}\n3. THIRD: {\"op\":\"add\",\"path\":\"/elements/root-key\",\"value\":{...with empty children}}\n4. THEN: Add child elements and append to parent's children array\n\nCORRECT EXAMPLE - Creating Grid with 3 Metrics:\n{\"op\":\"message\",\"role\":\"assistant\",\"content\":\"Creating your financial dashboard...\"}\n{\"op\":\"set\",\"path\":\"/root\",\"value\":\"main-stack\"}\n{\"op\":\"add\",\"path\":\"/elements/main-stack\",\"value\":{\"key\":\"main-stack\",\"type\":\"Stack\",\"props\":{\"gap\":\"lg\"},\"children\":[]}}\n{\"op\":\"add\",\"path\":\"/elements/metrics-grid\",\"value\":{\"key\":\"metrics-grid\",\"type\":\"Grid\",\"props\":{\"columns\":3,\"gap\":\"md\"},\"children\":[]}}\n{\"op\":\"add\",\"path\":\"/elements/main-stack/children/-\",\"value\":\"metrics-grid\"}\n{\"op\":\"add\",\"path\":\"/elements/metric-1\",\"value\":{\"key\":\"metric-1\",\"type\":\"Metric\",\"props\":{\"label\":\"Revenue\",\"value\":50000,\"format\":\"currency\"}}}\n{\"op\":\"add\",\"path\":\"/elements/metrics-grid/children/-\",\"value\":\"metric-1\"}\n{\"op\":\"add\",\"path\":\"/elements/metric-2\",\"value\":{\"key\":\"metric-2\",\"type\":\"Metric\",\"props\":{\"label\":\"Users\",\"value\":1200}}}\n{\"op\":\"add\",\"path\":\"/elements/metrics-grid/children/-\",\"value\":\"metric-2\"}\n{\"op\":\"add\",\"path\":\"/elements/metric-3\",\"value\":{\"key\":\"metric-3\",\"type\":\"Metric\",\"props\":{\"label\":\"Growth\",\"value\":0.15,\"format\":\"percent\",\"trend\":\"up\"}}}\n{\"op\":\"add\",\"path\":\"/elements/metrics-grid/children/-\",\"value\":\"metric-3\"}\n\nRULES:\n1. ALWAYS start children:[] empty, then append via /children/-\n2. NEVER pre-populate children array with keys in the initial add\n3. Add element BEFORE appending it to parent's children\n4. Each element must have: key, type, props (children optional)\n5. Do NOT wrap output in markdown code fences\n6. Output ONLY JSONL lines (one JSON object per line)\n\nRICH CONTENT PATTERN (for Document, Table, etc.):\nStream structure first, then populate with full content:\n{\"op\":\"add\",\"path\":\"/elements/doc\",\"value\":{\"key\":\"doc\",\"type\":\"Document\",\"props\":{\"title\":\"Report\"},\"children\":[]}}\n{\"op\":\"add\",\"path\":\"/elements/main-stack/children/-\",\"value\":\"doc\"}\n{\"op\":\"replace\",\"path\":\"/elements/doc/props/documents\",\"value\":[{\"title\":\"Section\",\"sections\":[{\"title\":\"Details\",\"content\":\"Full detailed content here with multiple paragraphs...\"}]}]}\n\nNEVER create empty Documents/Tables - ALWAYS populate content immediately after creation.`;\n}\n","/**\n * Interactive AI rules generators\n * Handles questions, suggestions, and proactivity patterns\n */\n\n/**\n * Generate interactive AI rules (questions, suggestions)\n */\nexport function generateInteractiveRules(preferForm: boolean): string {\n  return `\nINTERACTIVE AI BEHAVIOR:\n\nYou are a proactive, intelligent assistant. NEVER invent or assume data that you don't have.\n\n===============================================================================\nCRITICAL DECISION FRAMEWORK: WHEN TO ASK vs WHEN TO GENERATE\n===============================================================================\n\nSTEP 1 - ANALYZE THE REQUEST:\nBefore generating ANY UI, evaluate the user's request:\n\n IS THE REQUEST VAGUE?\n- \"Create a chart\" -> VAGUE (what data? what type? what labels?)\n- \"Create a bar chart showing monthly sales for Q1 2024\" -> SPECIFIC (has context)\n- \"Make a mind map\" -> VAGUE (what topic? what structure?)\n- \"Create a mind map of React component lifecycle\" -> SPECIFIC\n\n IS CRITICAL DATA MISSING?\nComponents that REQUIRE data arrays - NEVER generate with empty/fake data:\n- MindMap -> requires \"nodes\" array with {id, label, children?} structure\n- Graph -> requires \"nodes\" and \"edges\" arrays\n- Chart/BarChart/LineChart/PieChart -> requires \"data\" array with values\n- Table -> requires \"columns\" and \"rows\" arrays\n- TodoList -> requires \"items\" array (or can start empty if creating new)\n- Kanban -> requires \"columns\" with \"items\" arrays\n- Timeline -> requires \"events\" array\n- Calendar -> requires \"events\" array\n- TreeView -> requires \"nodes\" array with recursive structure\n\n IS DOMAIN-SPECIFIC INFO NEEDED?\n- Workout plans -> need exercises, sets, reps, muscle groups\n- Meal plans -> need meals, ingredients, calories, dietary restrictions\n- Schedules -> need dates, times, activities\n- Financial -> need amounts, categories, time periods\n\nSTEP 2 - DECIDE YOUR APPROACH:\n\n+-----------------------------------------------------------------------------+\n| IF request is vague OR data is missing OR domain info needed:               |\n|   -> ASK FIRST using 'question' operation                                   |\n|   -> DO NOT generate UI with placeholder/fake data                          |\n|   -> DO NOT assume what the user wants                                      |\n+-----------------------------------------------------------------------------+\n| IF request is specific AND has all required info:                           |\n|   -> GENERATE the UI directly                                               |\n|   -> Use ONLY the data provided by the user                                 |\n+-----------------------------------------------------------------------------+\n\n===============================================================================\nFORMAT SELECTION: WHEN TO USE FORM UI vs TEXT CHAT\n===============================================================================\n\nUSE FORM UI ({\"op\":\"question\",\"question\":{\"type\":\"form\",...}}) WHEN:\n- Collecting MULTIPLE related fields (3+ pieces of info)\n- Need STRUCTURED options (select, radio, checkbox)\n- Collecting DATES or NUMBERS with validation\n- Building a CONFIGURATION or SETTINGS\n- Need to collect DATA for arrays (items, rows, nodes)\n\nExamples requiring FORM UI:\n- \"Create a workout\" -> form with: exercise name, sets, reps, muscle group\n- \"Add calendar event\" -> form with: title, date, time, duration, description\n- \"Create a chart\" -> form with: chart type, data source, labels, values\n\nUSE TEXT CHAT (plain message or {\"op\":\"question\",\"question\":{\"type\":\"text\"}}) WHEN:\n- Asking a SINGLE clarifying question\n- Yes/No or simple CONFIRMATION\n- FREE-FORM creative input (topic ideas, descriptions)\n- User PREFERENCE without structure\n- Quick DISAMBIGUATION between 2-3 options\n\nExamples for TEXT CHAT:\n- \"What topic should the mind map cover?\"\n- \"Would you like me to add more detail to this section?\"\n- \"Should I use a light or dark theme?\"\n- \"Is this the format you wanted?\"\n\n${\n  preferForm\n    ? `CURRENT PREFERENCE: Forms are preferred for data collection.\nWhen in doubt between form and text, USE A FORM.`\n    : `CURRENT PREFERENCE: Text questions are preferred for simplicity.\nWhen in doubt between form and text, USE A TEXT QUESTION.`\n}\n\nUSE QUICK-REPLY ({\"op\":\"question\",\"question\":{\"type\":\"quick-reply\",...}}) WHEN:\n- Offering 2-5 PREDEFINED choices\n- Simple decisions or preferences\n- Yes/No/Maybe type questions\n- Selecting from a short list of options\n- When speed of response matters\n\nExamples for QUICK-REPLY:\n- \"Which format?\" with options: [PDF, Excel, CSV]\n- \"How should I proceed?\" with options: [Continue, Start over, Cancel]\n- \"Include details?\" with options: [Yes, detailed | No, summary only]\n\nIMPORTANT: Always set \"allowCustom\": true when user might want an option not listed.\n\n===============================================================================\nQUESTION OPERATION SYNTAX\n===============================================================================\n\n1. FORM QUESTION (for structured data collection):\n{\"op\":\"question\",\"question\":{\"id\":\"q1\",\"text\":\"I need details to create your [component]\",\"type\":\"form\",\"fields\":[\n  {\"id\":\"field1\",\"label\":\"Field Label\",\"type\":\"select\",\"options\":[{\"value\":\"opt1\",\"label\":\"Option 1\"},{\"value\":\"opt2\",\"label\":\"Option 2\"}],\"allowCustom\":true},\n  {\"id\":\"field2\",\"label\":\"Another Field\",\"type\":\"number\",\"placeholder\":\"Enter a number\"},\n  {\"id\":\"field3\",\"label\":\"Description\",\"type\":\"textarea\",\"placeholder\":\"Enter description\"}\n],\"required\":true}}\n\n2. QUICK-REPLY QUESTION (for simple choices):\n{\"op\":\"question\",\"question\":{\"id\":\"q1\",\"text\":\"How would you like to proceed?\",\"type\":\"quick-reply\",\"options\":[\n  {\"id\":\"opt1\",\"label\":\"Continue with details\",\"value\":\"detailed\",\"variant\":\"primary\"},\n  {\"id\":\"opt2\",\"label\":\"Keep it simple\",\"value\":\"simple\",\"variant\":\"default\"},\n  {\"id\":\"opt3\",\"label\":\"Start over\",\"value\":\"restart\",\"variant\":\"danger\"}\n],\"allowCustom\":true}}\n\n3. TEXT QUESTION (for open-ended clarification):\n{\"op\":\"question\",\"question\":{\"id\":\"q1\",\"text\":\"What topic would you like the mind map to cover?\",\"type\":\"text\",\"required\":true}}\n\nFORM FIELD TYPES:\n- \"text\": Single line text input\n- \"textarea\": Multi-line text input  \n- \"number\": Numeric input with optional min/max validation\n- \"select\": Dropdown with options array [{value, label}] - add \"allowCustom\":true for \"Other\" option\n- \"checkbox\": Boolean toggle\n- \"radio\": Single selection from options [{value, label}] - add \"allowCustom\":true for \"Other\" option\n- \"date\": Date picker\n\nQUICK-REPLY VARIANTS:\n- \"default\": Neutral option\n- \"primary\": Recommended/main option\n- \"success\": Positive action\n- \"danger\": Destructive or warning action\n\n===============================================================================\nRESPONSE TYPE DECISION GUIDE\n===============================================================================\n\nASK YOURSELF: What type of response will best serve the user?\n\n| Situation                          | Best Response Type     |\n|------------------------------------|------------------------|\n| Explaining something               | Plain text MESSAGE     |\n| 2-5 simple choices                 | QUICK-REPLY question   |\n| Collecting multiple data points    | FORM question          |\n| Open-ended creative input needed   | TEXT question          |\n| Generating UI as requested         | UI patches             |\n| Confirming an action               | QUICK-REPLY (Yes/No)   |\n| Providing follow-up options        | SUGGESTIONS            |\n\nWHEN TO USE PLAIN TEXT MESSAGE INSTEAD OF QUESTIONS:\n- When explaining or teaching something\n- When providing information or status\n- When the user just needs an answer, not a choice\n- When confirming you understood the request\n- When expressing that you cannot do something\n\nExample of plain text response:\n{\"op\":\"message\",\"role\":\"assistant\",\"content\":\"I've updated the chart with the new data. The total now shows 1,234 items across all categories.\"}\n\n===============================================================================\nHANDLING PREVIOUSLY COLLECTED DATA\n===============================================================================\n\nWhen the user responds to a question, you may receive \"PREVIOUSLY COLLECTED USER DATA\" \nin the prompt. This contains information the user has already provided.\n\nCRITICAL RULES:\n1. **NEVER re-ask for data that appears in PREVIOUSLY COLLECTED USER DATA**\n2. If you need additional information, ONLY ask for what is MISSING\n3. Use the collected data directly when generating UI components\n4. If a form has 5 fields and 3 are already collected, only show a form with the 2 missing fields\n\nExample - If previously collected data shows:\n{\"destination\": \"Rome\", \"travelers\": 2}\n\nAnd you need: destination, travelers, dates, budget\n-> ONLY ask for: dates, budget (NOT destination or travelers!)\n\nFor forms, use defaultValue to pre-populate known fields:\n{\"op\":\"question\",\"question\":{\"type\":\"form\",\"fields\":[\n  {\"id\":\"dates\",\"label\":\"Travel dates\",\"type\":\"date\"},\n  {\"id\":\"budget\",\"label\":\"Budget\",\"type\":\"number\"}\n]}}\n\n===============================================================================\nSTRICT RULES - VIOLATIONS ARE UNACCEPTABLE\n===============================================================================\n\n1. NEVER generate placeholder data:\n   - NO \"Lorem ipsum\", \"Sample text\", \"Example item\"\n   - NO \"Foo\", \"Bar\", \"Test\", \"Item 1\", \"Item 2\"\n   - NO fake dates, numbers, or names\n   - NO empty arrays when data is required for the component to function\n\n2. ALWAYS ask before generating when:\n   - User request is ambiguous or vague\n   - Component requires data arrays and none provided\n   - Domain-specific knowledge is needed\n   - You would need to invent/assume information\n\n3. NEVER make assumptions about:\n   - What data the user wants to display\n   - The structure or hierarchy of their data\n   - Domain-specific values (exercises, meals, prices, etc.)\n   - User preferences not explicitly stated\n\n4. When generating UI with user-provided data:\n   - Use EXACTLY the data given, nothing more\n   - Structure it correctly for the component\n   - If data seems incomplete, ASK for clarification\n\n5. NEVER ask for data already provided:\n   - Check PREVIOUSLY COLLECTED USER DATA before asking questions\n   - Pre-populate forms with known values using defaultValue\n   - Only prompt for truly missing information\n\n===============================================================================\nPROVIDING SUGGESTIONS\n===============================================================================\n\nAfter completing a response, suggest 2-4 relevant follow-up actions:\n{\"op\":\"suggestion\",\"suggestions\":[\n  {\"id\":\"s1\",\"label\":\"Add more details\",\"prompt\":\"Add more details to this component\",\"variant\":\"default\"},\n  {\"id\":\"s2\",\"label\":\"Create related view\",\"prompt\":\"Create a related component that shows additional data\",\"variant\":\"primary\"},\n  {\"id\":\"s3\",\"label\":\"Export data\",\"prompt\":\"Add an export functionality\",\"variant\":\"success\"}\n]}\n\nSUGGESTION RULES:\n1. Suggestions should be contextually relevant to what was just created/modified\n2. Use short, action-oriented labels (2-5 words)\n3. Include the full prompt that would be sent if user clicks\n4. Use variants: \"default\", \"primary\" (recommended), \"success\", \"warning\"\n5. Limit to 4 suggestions maximum`;\n}\n\n/**\n * Generate proactivity rules for context-aware AI behavior\n */\nexport function generateProactivityRules(): string {\n  return `\nPROACTIVE BEHAVIOR:\n\nWhen RECENT USER ACTIONS context is provided, you should be proactively helpful.\n\n===============================================================================\nCONTEXTUAL AWARENESS FRAMEWORK\n===============================================================================\n\n1. UNDERSTAND THE ACTION:\n   - What component did the user interact with?\n   - What specific action did they perform?\n   - What data/context is available from the action?\n\n2. INFER THE DOMAIN:\n   - Component type reveals the domain (e.g., Workout = fitness, TodoList = tasks)\n   - Adapt your language and suggestions to match the domain\n   - DO NOT assume cross-domain knowledge\n\n3. PROVIDE INTELLIGENT FOLLOW-UP:\n   - Ask relevant questions based on action and component context\n   - Suggest logical next steps\n   - Offer to enhance or expand on the action\n\n===============================================================================\nACTION TYPE RESPONSES\n===============================================================================\n\n- \"complete\" action -> Ask for feedback, notes, or rating about completed item\n- \"toggle\" action -> Acknowledge change, offer to undo or elaborate\n- \"input\" action -> Validate input, suggest related fields, confirm values\n- \"create\" action -> Suggest enhancements, related items, or next steps\n- \"delete\" action -> Confirm deletion, offer to restore or create replacement\n- \"update\" action -> Acknowledge update, suggest further refinements\n- \"select\" action -> Provide details about selection, offer actions on item\n- \"expand\" action -> Offer to add more detail to expanded content\n- \"collapse\" action -> Summarize or offer alternative views\n\n===============================================================================\nHANDLING INCOMPLETE DATA IN PROACTIVE RESPONSES\n===============================================================================\n\nWhen responding proactively, you may encounter components with incomplete data.\n\nRULES FOR INCOMPLETE DATA:\n1. DO NOT modify existing data unless explicitly asked\n2. If you need to ADD items, ASK for the data first\n3. If context from action is insufficient, ASK for clarification\n4. NEVER fill in missing data with assumptions or placeholders\n\nEXAMPLE - User completes a task in TodoList:\n- CORRECT: \"You completed [task name]. Would you like to add notes about how it went?\"\n- WRONG: \"You completed [task name]. I'll add some follow-up tasks for you.\" (assumes what tasks)\n\nEXAMPLE - User adds item to empty Kanban:\n- CORRECT: \"You added [item]. What other items would you like in this column?\"\n- WRONG: \"You added [item]. I'll populate the board with related items.\" (invents data)\n\n===============================================================================\nPROACTIVE RESPONSE FORMAT\n===============================================================================\n\nStart with a contextual message acknowledging the action:\n{\"op\":\"message\",\"role\":\"assistant\",\"content\":\"I noticed you [action] on [element]. Would you like to...?\"}\n\nThen, if additional info is needed, ask a focused question:\n{\"op\":\"question\",\"question\":{\"id\":\"feedback\",\"text\":\"\",\"type\":\"form\",\"fields\":[\n  {\"id\":\"response\",\"label\":\"Your feedback\",\"type\":\"text\"}\n]}}\n\nOr suggest relevant follow-up actions:\n{\"op\":\"suggestion\",\"suggestions\":[\n  {\"id\":\"s1\",\"label\":\"Add details\",\"prompt\":\"Add more details to this item\",\"variant\":\"default\"}\n]}\n\n===============================================================================\nPROACTIVITY RULES\n===============================================================================\n\n1. Be helpful but not intrusive - one follow-up per action batch\n2. Infer question relevance from the component type and action context\n3. Keep questions brief and easy to answer\n4. Respect when user ignores follow-up (don't re-ask)\n5. Use the component's props schema to understand what data is relevant\n6. NEVER auto-generate additional data based on user actions\n7. ALWAYS ask before expanding, adding, or modifying data`;\n}\n","import type { UITree } from \"../types\";\n\n/**\n * Info about native browser text selection\n */\nexport interface TextSelectionForPrompt {\n  /** The selected text */\n  text: string;\n  /** The JSON-UI element key containing the selection */\n  elementKey?: string;\n  /** The component type */\n  elementType?: string;\n}\n\n/**\n * Layout info for prompt generation\n */\nexport interface LayoutInfoForPrompt {\n  elementKey: string;\n  elementType: string;\n  size?: {\n    width?: number | string;\n    height?: number | string;\n  };\n  grid?: {\n    column?: number;\n    row?: number;\n    columnSpan?: number;\n    rowSpan?: number;\n  };\n  resizable?: boolean;\n}\n\n/**\n * Action type for tracked user actions\n */\nexport type TrackedActionType =\n  | \"toggle\"\n  | \"input\"\n  | \"select\"\n  | \"click\"\n  | \"complete\"\n  | \"create\"\n  | \"delete\"\n  | \"update\"\n  | \"submit\"\n  | \"expand\"\n  | \"collapse\"\n  | \"drag\"\n  | \"drop\";\n\n/**\n * Tracked action interface for prompt generation\n */\nexport interface TrackedActionForPrompt {\n  type: TrackedActionType;\n  elementKey: string;\n  elementType: string;\n  timestamp: number;\n  context?: {\n    itemId?: string;\n    itemIndex?: number;\n    itemLabel?: string;\n    previousValue?: unknown;\n    newValue?: unknown;\n  };\n}\n\n/**\n * Generate context-aware prompt additions for tree state\n */\nexport function generateTreeContextPrompt(\n  tree: unknown,\n  options?: { isPruned?: boolean; totalElements?: number },\n): string {\n  const prunedNote = options?.isPruned\n    ? `\\nNOTE: This is a PRUNED tree showing only elements relevant to current context.\nTotal elements in full tree: ${options.totalElements ?? \"unknown\"}\nOnly the shown elements can be modified. To access other elements, the user must select them first.`\n    : \"\";\n\n  return `\nCURRENT UI STATE (JSON TREE):\n${JSON.stringify(tree, null, 2)}${prunedNote}\n\nIMPORTANT:\n1. DO NOT create a new root container if one already exists. Reuse the existing root.\n2. DO NOT wrap the existing content in a new Card/Stack/Grid. Just add new elements to the existing root's children.\n3. Reuse existing keys for elements that shouldn't change.\n4. To ADD an element:\n   - Output {\"op\":\"add\", \"path\":\"/elements/NEW_KEY\", \"value\":{...}}\n   - Output {\"op\":\"ensure\", \"path\":\"/elements/PARENT_KEY\", \"value\":{parent element}} (CRITICAL: ensures parent exists!)\n   - Output {\"op\":\"add\", \"path\":\"/elements/PARENT_KEY/children/-\", \"value\":\"NEW_KEY\"}\n5. To REMOVE an element:\n   - Output {\"op\":\"remove\", \"path\":\"/elements/KEY_TO_REMOVE\"}\n   - Output {\"op\":\"remove\", \"path\":\"/elements/PARENT_KEY/children/INDEX_OF_KEY\"}\n6. To UPDATE an element:\n   - Output {\"op\":\"replace\", \"path\":\"/elements/KEY/props/PROPERTY\", \"value\":\"NEW_VALUE\"}\n7. To UPDATE LAYOUT (size, grid position):\n   - Output {\"op\":\"replace\", \"path\":\"/elements/KEY/layout/size/width\", \"value\":300}\n   - Output {\"op\":\"replace\", \"path\":\"/elements/KEY/layout/grid/columnSpan\", \"value\":2}\n   - Output {\"op\":\"replace\", \"path\":\"/elements/KEY/layout/resizable\", \"value\":true}\n\nCRITICAL: ALWAYS use {\"op\":\"ensure\"} BEFORE adding to a parent's children. This prevents errors if parent doesn't exist.\nDO NOT re-output the entire tree unless requested to reset/clear. Work incrementally.`;\n}\n\n/**\n * Generate context-aware prompt additions for selection\n */\nexport function generateSelectionContextPrompt(\n  selection: { key: string; subItems?: string[] },\n  hasSubItems: boolean,\n): string {\n  let prompt = `\nSELECTED ELEMENT CONTEXT:\n${JSON.stringify(selection, null, 2)}\n\nEDITING RULES:`;\n\n  if (hasSubItems) {\n    prompt += `\nThe user has selected specific items within this component.\nSelected item IDs: ${JSON.stringify(selection.subItems)}\n\nFocus your response on these selected items:\n- Use \"replace\" operations to update their properties\n- Find each item's index by matching its \"id\" in the element's data array\n- Example: {\"op\":\"replace\",\"path\":\"/elements/${selection.key}/props/items/INDEX/description\",\"value\":\"Updated content\"}`;\n  } else {\n    prompt += `\n- Apply the smallest possible patch that satisfies the user request.\n- Prefer updates inside the selected element's props or its list data.\n- You may modify the selected element's children if needed.\n- Only edit parent/layout elements if the change explicitly requires it.`;\n  }\n\n  return prompt;\n}\n\n/**\n * Generate deep selection context prompt\n */\nexport function generateDeepSelectionPrompt(\n  deepSelections: Array<{\n    textContent: string;\n    itemId?: string;\n    selectionType: string;\n    elementKey?: string;\n  }>,\n): string {\n  const selectionSummary = deepSelections\n    .map((s) => {\n      const preview =\n        s.textContent.length > 60\n          ? s.textContent.substring(0, 60) + \"...\"\n          : s.textContent;\n      return `- \"${preview}\" (${s.selectionType}, itemId: ${s.itemId || \"none\"}, element: ${s.elementKey || \"unknown\"})`;\n    })\n    .join(\"\\n\");\n\n  return `\nCRITICAL: USER HAS SELECTED SPECIFIC ELEMENTS\nThe user explicitly selected these ${deepSelections.length} item(s):\n${selectionSummary}\n\nFULL SELECTION DATA:\n${JSON.stringify(deepSelections, null, 2)}\n\nSTRICT RULES FOR SELECTED ELEMENTS:\n1. ONLY modify the items that the user selected - DO NOT touch any other items\n2. If user asks to \"expand\" or \"elaborate\", ONLY expand the selected items\n3. If user asks to \"change\" something, ONLY change the selected items\n4. Find each selected item by matching its itemId or textContent in the component's data\n5. Use \"replace\" operations targeting the specific array index of each selected item\n6. Other items in the same component must remain EXACTLY as they are\n7. You may modify the LAYOUT (size, position) of selected elements if relevant to the request`;\n}\n\n/**\n * Generate prompt section for native text selection\n */\nexport function generateTextSelectionPrompt(\n  textSelection: TextSelectionForPrompt,\n): string {\n  const componentInfo = textSelection.elementKey\n    ? `\\nThis text is from component: ${textSelection.elementKey}${textSelection.elementType ? ` (${textSelection.elementType})` : \"\"}`\n    : \"\";\n\n  return `\nUSER HAS HIGHLIGHTED/SELECTED TEXT:\n\"${textSelection.text}\"${componentInfo}\n\nThe user has explicitly selected this text. Their message likely refers to it.\nPossible intents:\n- Ask questions about this specific text\n- Request modifications or expansion of this content\n- Use it as context for their question\n- Quote it in a new component\n\nConsider this selected text as the PRIMARY FOCUS of the user's request.`;\n}\n\n/**\n * Generate prompt section for layout-aware operations\n */\nexport function generateLayoutContextPrompt(\n  layouts: LayoutInfoForPrompt[],\n): string {\n  if (layouts.length === 0) return \"\";\n\n  const layoutSummary = layouts\n    .map((l) => {\n      const parts = [`- ${l.elementKey} (${l.elementType})`];\n      if (l.size?.width || l.size?.height) {\n        parts.push(\n          `size: ${l.size.width ?? \"auto\"} x ${l.size.height ?? \"auto\"}`,\n        );\n      }\n      if (l.grid?.column || l.grid?.row) {\n        parts.push(\n          `grid: col ${l.grid.column ?? \"auto\"}, row ${l.grid.row ?? \"auto\"}`,\n        );\n      }\n      if (l.grid?.columnSpan && l.grid.columnSpan > 1) {\n        parts.push(`span: ${l.grid.columnSpan} cols`);\n      }\n      if (l.resizable) {\n        parts.push(\"(resizable)\");\n      }\n      return parts.join(\" | \");\n    })\n    .join(\"\\n\");\n\n  return `\nLAYOUT CONTEXT:\nThe following elements have explicit layout configurations:\n${layoutSummary}\n\nLAYOUT OPERATIONS:\n- To RESIZE an element:\n  {\"op\":\"replace\",\"path\":\"/elements/KEY/layout/size\",\"value\":{\"width\":400,\"height\":300}}\n- To REPOSITION in grid:\n  {\"op\":\"replace\",\"path\":\"/elements/KEY/layout/grid\",\"value\":{\"column\":1,\"columnSpan\":6}}\n- To ENABLE resize handles:\n  {\"op\":\"replace\",\"path\":\"/elements/KEY/layout/resizable\",\"value\":true}\n- To SET full layout at once:\n  {\"op\":\"replace\",\"path\":\"/elements/KEY/layout\",\"value\":{\"size\":{\"width\":500},\"grid\":{\"columnSpan\":4},\"resizable\":true}}\n\nWhen the user mentions size, width, height, position, columns, or layout, use these operations.`;\n}\n\n/**\n * Generate context-aware prompt for recent user actions (proactivity)\n */\nexport function generateActionsContextPrompt(\n  actions: TrackedActionForPrompt[],\n): string {\n  if (actions.length === 0) return \"\";\n\n  const formatted = actions.map((action) => {\n    const parts = [`- ${action.type} on ${action.elementType}`];\n\n    if (action.context?.itemLabel) {\n      parts.push(`\"${action.context.itemLabel}\"`);\n    }\n\n    if (\n      action.context?.previousValue !== undefined &&\n      action.context?.newValue !== undefined\n    ) {\n      parts.push(\n        `(${action.context.previousValue} -> ${action.context.newValue})`,\n      );\n    }\n\n    return parts.join(\" \");\n  });\n\n  const lastAction = actions[actions.length - 1];\n  if (!lastAction) return \"\";\n\n  return `\nRECENT USER ACTIONS:\n${formatted.join(\"\\n\")}\n\nLAST ACTION DETAILS:\n${JSON.stringify(lastAction, null, 2)}\n\nPROACTIVE INSTRUCTION:\nThe user just performed the action above. Analyze:\n1. The ELEMENT TYPE (${lastAction.elementType}) - what kind of component is this?\n2. The ACTION TYPE (${lastAction.type}) - what did the user do?\n3. The CONTEXT - any item labels, values, or indices involved?\n\nBased on this analysis, provide a contextual, helpful follow-up that:\n- Is relevant to the component type and its purpose\n- Acknowledges the specific action taken\n- Offers useful next steps or asks for relevant information\n- Does NOT assume domain-specific knowledge (e.g., don't assume workout if it's a TodoList)\n\nYour response should feel natural and helpful, adapting to whatever domain the component represents.`;\n}\n","import type { Catalog, ComponentDefinition } from \"./catalog\";\nimport type { TypedComponentDefinition } from \"./component\";\nimport type { ActionDefinition } from \"./actions\";\nimport type { ValidationFunction } from \"./validation\";\n\n// Import from modular prompt utilities\nimport { describeZodSchema } from \"./prompt/schema-describer\";\nimport {\n  generateStreamingStrategy,\n  generateLayoutRules,\n  generateMessageRules,\n  generateSelectionRules,\n  generateOutputFormat,\n} from \"./prompt/rules-generator\";\nimport {\n  generateInteractiveRules,\n  generateProactivityRules,\n} from \"./prompt/interactive-rules\";\nimport {\n  generateTreeContextPrompt,\n  generateSelectionContextPrompt,\n  generateDeepSelectionPrompt,\n  generateTextSelectionPrompt,\n  generateLayoutContextPrompt,\n  generateActionsContextPrompt,\n} from \"./prompt/context-prompts\";\nimport {\n  generateStructuredOutputPrompt,\n  generateStructuredOutputFormat,\n  generateComponentSchemas,\n  generateValidationHints,\n} from \"./prompt/structured-output\";\n\n// Re-export for convenience\nexport {\n  describeZodSchema,\n  generateStreamingStrategy,\n  generateLayoutRules,\n  generateMessageRules,\n  generateSelectionRules,\n  generateOutputFormat,\n  generateInteractiveRules,\n  generateProactivityRules,\n  generateTreeContextPrompt,\n  generateSelectionContextPrompt,\n  generateDeepSelectionPrompt,\n  generateTextSelectionPrompt,\n  generateLayoutContextPrompt,\n  generateActionsContextPrompt,\n  // New structured output exports\n  generateStructuredOutputPrompt,\n  generateStructuredOutputFormat,\n  generateComponentSchemas,\n  generateValidationHints,\n};\n\nexport type {\n  TextSelectionForPrompt,\n  LayoutInfoForPrompt,\n  TrackedActionType,\n  TrackedActionForPrompt,\n} from \"./prompt/context-prompts\";\n\nexport type { StructuredOutputConfig } from \"./prompt/structured-output\";\n\n/**\n * Configuration for prompt generation\n */\nexport interface PromptGeneratorConfig {\n  /** Custom intro text before component list */\n  introText?: string;\n  /** Include streaming strategy hints */\n  includeStreamingStrategy?: boolean;\n  /** Include selection context rules */\n  includeSelectionRules?: boolean;\n  /** Include message rules */\n  includeMessageRules?: boolean;\n  /** Include layout rules for spacing */\n  includeLayoutRules?: boolean;\n  /** Include interactive AI rules (questions, suggestions) */\n  includeInteractiveRules?: boolean;\n  /** Include proactivity rules */\n  includeProactivityRules?: boolean;\n  /** Data collection preference: form or text */\n  dataCollectionPreferForm?: boolean;\n  /** Custom component-specific rules */\n  componentRules?: Record<string, string>;\n  /** Skills content from skills.md files (component name -> content) */\n  skills?: Record<string, string>;\n  /** Additional sections to append before the final prompt line */\n  extraSections?: string[];\n  /** Final prompt line (defaults to \"Generate JSONL patches now:\") */\n  outroText?: string;\n}\n\n/**\n * Generate component documentation from a definition\n */\nfunction generateComponentDoc(\n  name: string,\n  definition: ComponentDefinition | TypedComponentDefinition,\n): string {\n  const propsDesc = describeZodSchema(definition.props);\n  const desc = definition.description || \"\";\n  const children = definition.hasChildren ? \" (supports children)\" : \"\";\n\n  return `- ${name}: ${propsDesc}${children}${desc ? ` - ${desc}` : \"\"}`;\n}\n\n/**\n * Generate a complete system prompt from a catalog\n */\nexport function generateSystemPrompt<\n  TComponents extends Record<string, ComponentDefinition>,\n  TActions extends Record<string, ActionDefinition> = Record<\n    string,\n    ActionDefinition\n  >,\n  TFunctions extends Record<string, ValidationFunction> = Record<\n    string,\n    ValidationFunction\n  >,\n>(\n  catalog: Catalog<TComponents, TActions, TFunctions>,\n  config: PromptGeneratorConfig = {},\n): string {\n  const {\n    introText = \"You are a dashboard widget generator that outputs JSONL (JSON Lines) patches.\",\n    includeStreamingStrategy = true,\n    includeSelectionRules = true,\n    includeMessageRules = true,\n    includeLayoutRules = true,\n    includeInteractiveRules = true,\n    includeProactivityRules = true,\n    dataCollectionPreferForm = true,\n    componentRules = {},\n    skills = {},\n    extraSections = [],\n    outroText = \"Generate JSONL patches now:\",\n  } = config;\n\n  const lines: string[] = [introText, \"\"];\n\n  // Component list\n  lines.push(\"AVAILABLE COMPONENTS:\");\n  lines.push(catalog.componentNames.map(String).join(\", \"));\n  lines.push(\"\");\n\n  // Component details\n  lines.push(\"COMPONENT DETAILS:\");\n  for (const name of catalog.componentNames) {\n    const def = catalog.components[name];\n    if (def) {\n      lines.push(generateComponentDoc(String(name), def));\n    }\n  }\n  lines.push(\"\");\n\n  // Skills (from skills.md files)\n  const skillsWithContent = Object.entries(skills).filter(\n    ([, content]) => content && content.trim(),\n  );\n  if (skillsWithContent.length > 0) {\n    lines.push(\"COMPONENT AI HINTS:\");\n    for (const [name, content] of skillsWithContent) {\n      lines.push(`\\n### ${name}`);\n      lines.push(content.trim());\n    }\n    lines.push(\"\");\n  }\n\n  // Output format\n  lines.push(generateOutputFormat());\n\n  // Layout rules\n  if (includeLayoutRules) {\n    lines.push(generateLayoutRules());\n  }\n\n  // Streaming strategy\n  if (includeStreamingStrategy) {\n    lines.push(generateStreamingStrategy());\n  }\n\n  // Message rules\n  if (includeMessageRules) {\n    lines.push(generateMessageRules());\n  }\n\n  // Selection rules\n  if (includeSelectionRules) {\n    lines.push(generateSelectionRules());\n  }\n\n  // Interactive AI rules (questions, suggestions)\n  if (includeInteractiveRules) {\n    lines.push(generateInteractiveRules(dataCollectionPreferForm));\n  }\n\n  // Proactivity rules\n  if (includeProactivityRules) {\n    lines.push(generateProactivityRules());\n  }\n\n  // Custom component rules\n  const rulesEntries = Object.entries(componentRules);\n  if (rulesEntries.length > 0) {\n    lines.push(\"\");\n    lines.push(\"COMPONENT SELECTION RULES:\");\n    for (const [component, rule] of rulesEntries) {\n      lines.push(`- ALWAYS use '${component}' ${rule}`);\n    }\n  }\n\n  if (extraSections.length > 0) {\n    lines.push(\"\");\n    lines.push(...extraSections);\n  }\n\n  lines.push(\"\");\n  lines.push(outroText);\n\n  return lines.join(\"\\n\");\n}\n","/**\n * Streaming Schemas - Zod schemas for structured streaming output\n */\nimport { z } from \"zod\";\n\n// =============================================================================\n// Metadata Schema\n// =============================================================================\n\nexport const UIElementMetaSchema = z.object({\n  turnId: z.string().describe(\"Unique ID for the AI turn that created this\"),\n  sequence: z\n    .number()\n    .int()\n    .nonnegative()\n    .describe(\"Sequence number within turn\"),\n  createdAt: z.number().describe(\"Unix timestamp of creation\"),\n  updatedAt: z.number().optional().describe(\"Unix timestamp of last update\"),\n});\n\n// =============================================================================\n// Patch Schema (JSON Patch RFC 6902)\n// =============================================================================\n\nexport const StreamPatchSchema = z.object({\n  op: z.enum([\"add\", \"replace\", \"remove\", \"move\", \"copy\", \"test\"]),\n  path: z.string().regex(/^\\//, \"Path must start with /\"),\n  value: z.unknown().optional(),\n  from: z.string().optional(),\n});\n\n// =============================================================================\n// Message Type Schemas (Discriminated Union)\n// =============================================================================\n\nexport const PatchMessageSchema = z.object({\n  type: z.literal(\"patch\"),\n  patches: z.array(StreamPatchSchema),\n  targetPath: z.string().optional(),\n});\n\nexport const ChatMessageSchema = z.object({\n  type: z.literal(\"message\"),\n  role: z.enum([\"user\", \"assistant\", \"system\"]),\n  content: z.string(),\n  id: z.string().optional(),\n});\n\nexport const QuestionMessageSchema = z.object({\n  type: z.literal(\"question\"),\n  questionId: z.string(),\n  prompt: z.string(),\n  options: z\n    .array(\n      z.object({\n        label: z.string(),\n        value: z.string(),\n      }),\n    )\n    .optional(),\n  inputType: z\n    .enum([\"text\", \"select\", \"multiselect\", \"number\", \"date\"])\n    .optional(),\n  required: z.boolean().optional(),\n});\n\nexport const SuggestionMessageSchema = z.object({\n  type: z.literal(\"suggestion\"),\n  suggestions: z.array(\n    z.object({\n      id: z.string(),\n      label: z.string(),\n      action: z.string().optional(),\n    }),\n  ),\n});\n\nexport const ToolProgressMessageSchema = z.object({\n  type: z.literal(\"tool-progress\"),\n  toolId: z.string(),\n  toolName: z.string(),\n  status: z.enum([\"pending\", \"running\", \"complete\", \"error\"]),\n  progress: z.number().min(0).max(100).optional(),\n  message: z.string().optional(),\n  result: z.unknown().optional(),\n});\n\nexport const StreamControlSchema = z.object({\n  type: z.literal(\"control\"),\n  action: z.enum([\"start\", \"end\", \"error\", \"abort\"]),\n  error: z\n    .object({\n      code: z.string(),\n      message: z.string(),\n      recoverable: z.boolean(),\n    })\n    .optional(),\n});\n\n// =============================================================================\n// Stream Message (Discriminated Union)\n// =============================================================================\n\nexport const StreamMessageSchema = z.discriminatedUnion(\"type\", [\n  PatchMessageSchema,\n  ChatMessageSchema,\n  QuestionMessageSchema,\n  SuggestionMessageSchema,\n  ToolProgressMessageSchema,\n  StreamControlSchema,\n]);\n\n// =============================================================================\n// Stream Frame (Top-level envelope)\n// =============================================================================\n\nexport const StreamFrameSchema = z.object({\n  version: z.literal(\"2.0\").describe(\"Protocol version\"),\n  timestamp: z.number().describe(\"Unix timestamp\"),\n  correlationId: z.string().uuid().describe(\"Request correlation ID\"),\n  sequence: z.number().int().nonnegative().describe(\"Frame sequence number\"),\n  message: StreamMessageSchema,\n});\n\n// =============================================================================\n// UI Element Schema (Strict version)\n// =============================================================================\n\n// Define the base schema without recursion first\nconst UIElementBaseSchema = z.object({\n  key: z.string().describe(\"Unique element key (REQUIRED)\"),\n  type: z.string().describe(\"Component type from catalog (REQUIRED)\"),\n  props: z\n    .record(z.string(), z.unknown())\n    .describe(\"Component props (REQUIRED)\"),\n  parentKey: z.string().optional(),\n  layout: z\n    .object({\n      grid: z\n        .object({\n          column: z.number().optional(),\n          row: z.number().optional(),\n          columnSpan: z.number().optional(),\n          rowSpan: z.number().optional(),\n        })\n        .optional(),\n      size: z\n        .object({\n          width: z.union([z.number(), z.string()]).optional(),\n          height: z.union([z.number(), z.string()]).optional(),\n          minWidth: z.union([z.number(), z.string()]).optional(),\n          maxWidth: z.union([z.number(), z.string()]).optional(),\n          minHeight: z.union([z.number(), z.string()]).optional(),\n          maxHeight: z.union([z.number(), z.string()]).optional(),\n        })\n        .optional(),\n      resizable: z.boolean().optional(),\n    })\n    .optional(),\n  visible: z.boolean().optional(),\n  locked: z.boolean().optional(),\n  _meta: UIElementMetaSchema.optional(),\n});\n\n// Type for recursive schema\ntype UIElementInput = z.input<typeof UIElementBaseSchema> & {\n  children?: UIElementInput[];\n};\n\n// Export the recursive schema with explicit typing\nexport const UIElementSchema: z.ZodType<UIElementInput> =\n  UIElementBaseSchema.extend({\n    children: z.lazy(() => z.array(UIElementSchema)).optional(),\n  });\n","/**\n * Stream Validation Pipeline\n *\n * Validates incoming stream frames and provides error recovery.\n */\nimport { z } from \"zod\";\nimport {\n  StreamFrameSchema,\n  StreamPatchSchema,\n  UIElementSchema,\n  StreamMessageSchema,\n} from \"./schemas\";\nimport type {\n  StreamFrame,\n  StreamPatch,\n  ValidationResult,\n  ValidationError,\n  ValidationWarning,\n} from \"./types\";\n\n// =============================================================================\n// Validation Pipeline\n// =============================================================================\n\nexport class StreamValidationPipeline {\n  private componentTypes: Set<string>;\n\n  constructor(registeredComponents?: string[]) {\n    this.componentTypes = new Set(registeredComponents ?? []);\n  }\n\n  /**\n   * Register component types for validation\n   */\n  registerComponentTypes(types: string[]): void {\n    types.forEach((t) => this.componentTypes.add(t));\n  }\n\n  /**\n   * Validate a complete stream frame\n   */\n  validateFrame(data: unknown): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    const result = StreamFrameSchema.safeParse(data);\n\n    if (!result.success) {\n      for (const issue of result.error.issues) {\n        errors.push({\n          path: issue.path.join(\".\"),\n          code: issue.code,\n          message: issue.message,\n        });\n      }\n      return { valid: false, errors, warnings };\n    }\n\n    // Additional semantic validation\n    const frame = result.data;\n\n    // Validate sequence is non-negative\n    if (frame.sequence < 0) {\n      errors.push({\n        path: \"sequence\",\n        code: \"INVALID_SEQUENCE\",\n        message: \"Sequence must be non-negative\",\n      });\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Validate a stream message\n   */\n  validateMessage(data: unknown): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    const result = StreamMessageSchema.safeParse(data);\n\n    if (!result.success) {\n      for (const issue of result.error.issues) {\n        errors.push({\n          path: issue.path.join(\".\"),\n          code: issue.code,\n          message: issue.message,\n        });\n      }\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Validate a single patch operation\n   */\n  validatePatch(patch: unknown): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    const result = StreamPatchSchema.safeParse(patch);\n\n    if (!result.success) {\n      for (const issue of result.error.issues) {\n        errors.push({\n          path: issue.path.join(\".\"),\n          code: issue.code,\n          message: issue.message,\n        });\n      }\n      return { valid: false, errors, warnings };\n    }\n\n    const p = result.data;\n\n    // Validate path format\n    if (!p.path.startsWith(\"/\")) {\n      errors.push({\n        path: \"path\",\n        code: \"INVALID_PATH\",\n        message: \"Path must start with /\",\n      });\n    }\n\n    // Validate value for add/replace\n    if ((p.op === \"add\" || p.op === \"replace\") && p.value === undefined) {\n      errors.push({\n        path: \"value\",\n        code: \"MISSING_VALUE\",\n        message: `Value required for ${p.op} operation`,\n      });\n    }\n\n    // Validate from for move/copy\n    if ((p.op === \"move\" || p.op === \"copy\") && !p.from) {\n      errors.push({\n        path: \"from\",\n        code: \"MISSING_FROM\",\n        message: `From path required for ${p.op} operation`,\n      });\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Validate a UI element against catalog\n   */\n  validateElement(element: unknown): ValidationResult {\n    const errors: ValidationError[] = [];\n    const warnings: ValidationWarning[] = [];\n\n    const result = UIElementSchema.safeParse(element);\n\n    if (!result.success) {\n      for (const issue of result.error.issues) {\n        errors.push({\n          path: issue.path.join(\".\"),\n          code: issue.code,\n          message: issue.message,\n        });\n      }\n      return { valid: false, errors, warnings };\n    }\n\n    const el = result.data;\n\n    // Validate component type if catalog is provided\n    if (this.componentTypes.size > 0 && !this.componentTypes.has(el.type)) {\n      warnings.push({\n        path: \"type\",\n        code: \"UNKNOWN_COMPONENT\",\n        message: `Unknown component type: ${el.type}`,\n      });\n    }\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Parse and validate with auto-fix for recoverable errors\n   */\n  parseWithRecovery(data: unknown): {\n    frame: StreamFrame | null;\n    validation: ValidationResult;\n    recovered: boolean;\n  } {\n    const validation = this.validateFrame(data);\n\n    if (validation.valid) {\n      return {\n        frame: data as StreamFrame,\n        validation,\n        recovered: false,\n      };\n    }\n\n    // Try to recover by fixing common issues\n    const fixed = this.tryAutoFix(data);\n    if (fixed) {\n      const revalidation = this.validateFrame(fixed);\n      if (revalidation.valid) {\n        revalidation.warnings.push({\n          path: \"\",\n          code: \"AUTO_FIXED\",\n          message: \"Frame was auto-fixed\",\n          autoFixed: true,\n        });\n        return {\n          frame: fixed as StreamFrame,\n          validation: revalidation,\n          recovered: true,\n        };\n      }\n    }\n\n    return { frame: null, validation, recovered: false };\n  }\n\n  /**\n   * Try to auto-fix common issues\n   */\n  private tryAutoFix(data: unknown): unknown | null {\n    if (typeof data !== \"object\" || data === null) return null;\n\n    const obj = { ...data } as Record<string, unknown>;\n\n    // Fix missing version\n    if (!obj.version) {\n      obj.version = \"2.0\";\n    }\n\n    // Fix missing timestamp\n    if (!obj.timestamp) {\n      obj.timestamp = Date.now();\n    }\n\n    // Fix missing correlationId\n    if (!obj.correlationId) {\n      obj.correlationId = crypto.randomUUID();\n    }\n\n    // Fix missing sequence\n    if (typeof obj.sequence !== \"number\") {\n      obj.sequence = 0;\n    }\n\n    return obj;\n  }\n}\n\n// =============================================================================\n// Factory Function\n// =============================================================================\n\nexport function createValidationPipeline(\n  componentTypes?: string[],\n): StreamValidationPipeline {\n  return new StreamValidationPipeline(componentTypes);\n}\n","/**\n * Patch Buffer - Handles out-of-order patch reordering\n */\nimport type { StreamPatch, StreamFrame } from \"./types\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\ninterface BufferedFrame {\n  frame: StreamFrame;\n  receivedAt: number;\n}\n\ninterface FlushResult {\n  frames: StreamFrame[];\n  gaps: number[];\n}\n\n// =============================================================================\n// Patch Buffer Class\n// =============================================================================\n\nexport class PatchBuffer {\n  private buffer: Map<number, BufferedFrame> = new Map();\n  private expectedSequence = 0;\n  private readonly maxBufferSize: number;\n  private readonly gapTimeout: number;\n  private readonly flushInterval: number;\n  private flushTimer: ReturnType<typeof setTimeout> | null = null;\n  private onFlush: ((frames: StreamFrame[]) => void) | null = null;\n\n  constructor(\n    options: {\n      maxBufferSize?: number;\n      gapTimeout?: number;\n      flushInterval?: number;\n    } = {},\n  ) {\n    this.maxBufferSize = options.maxBufferSize ?? 100;\n    this.gapTimeout = options.gapTimeout ?? 5000;\n    this.flushInterval = options.flushInterval ?? 50;\n  }\n\n  /**\n   * Set flush callback\n   */\n  setOnFlush(callback: (frames: StreamFrame[]) => void): void {\n    this.onFlush = callback;\n  }\n\n  /**\n   * Add a frame to the buffer\n   */\n  add(frame: StreamFrame): void {\n    const { sequence } = frame;\n\n    // Store in buffer\n    this.buffer.set(sequence, {\n      frame,\n      receivedAt: Date.now(),\n    });\n\n    // If this is the expected sequence, try to flush\n    if (sequence === this.expectedSequence) {\n      this.scheduleFlush();\n    }\n\n    // If buffer is too large, force flush with gaps\n    if (this.buffer.size > this.maxBufferSize) {\n      this.forceFlush();\n    }\n  }\n\n  /**\n   * Schedule a flush\n   */\n  private scheduleFlush(): void {\n    if (this.flushTimer) return;\n\n    this.flushTimer = setTimeout(() => {\n      this.flushTimer = null;\n      this.flush();\n    }, this.flushInterval);\n  }\n\n  /**\n   * Flush in-order frames\n   */\n  flush(): FlushResult {\n    const frames: StreamFrame[] = [];\n    const gaps: number[] = [];\n\n    while (this.buffer.has(this.expectedSequence)) {\n      const buffered = this.buffer.get(this.expectedSequence)!;\n      frames.push(buffered.frame);\n      this.buffer.delete(this.expectedSequence);\n      this.expectedSequence++;\n    }\n\n    if (frames.length > 0 && this.onFlush) {\n      this.onFlush(frames);\n    }\n\n    return { frames, gaps };\n  }\n\n  /**\n   * Force flush with gap handling\n   */\n  forceFlush(): FlushResult {\n    const frames: StreamFrame[] = [];\n    const gaps: number[] = [];\n    const now = Date.now();\n\n    // Find the minimum sequence in buffer\n    let minSeq = Infinity;\n    for (const seq of this.buffer.keys()) {\n      if (seq < minSeq) minSeq = seq;\n    }\n\n    if (minSeq === Infinity) {\n      return { frames, gaps };\n    }\n\n    // Check for timed-out gaps\n    while (minSeq > this.expectedSequence) {\n      const buffered = this.buffer.get(minSeq);\n      if (buffered && now - buffered.receivedAt > this.gapTimeout) {\n        // Gap has timed out, skip to minSeq\n        for (let i = this.expectedSequence; i < minSeq; i++) {\n          gaps.push(i);\n        }\n        this.expectedSequence = minSeq;\n        break;\n      }\n      break;\n    }\n\n    // Flush available frames\n    return this.flush();\n  }\n\n  /**\n   * Reset buffer state\n   */\n  reset(): void {\n    this.buffer.clear();\n    this.expectedSequence = 0;\n    if (this.flushTimer) {\n      clearTimeout(this.flushTimer);\n      this.flushTimer = null;\n    }\n  }\n\n  /**\n   * Get buffer statistics\n   */\n  getStats(): {\n    bufferedCount: number;\n    expectedSequence: number;\n    oldestAge: number;\n  } {\n    let oldestAge = 0;\n    const now = Date.now();\n\n    for (const buffered of this.buffer.values()) {\n      const age = now - buffered.receivedAt;\n      if (age > oldestAge) oldestAge = age;\n    }\n\n    return {\n      bufferedCount: this.buffer.size,\n      expectedSequence: this.expectedSequence,\n      oldestAge,\n    };\n  }\n}\n\n// =============================================================================\n// Factory Function\n// =============================================================================\n\nexport function createPatchBuffer(options?: {\n  maxBufferSize?: number;\n  gapTimeout?: number;\n  flushInterval?: number;\n}): PatchBuffer {\n  return new PatchBuffer(options);\n}\n","/**\n * Placeholder Manager - Handles forward-reference resolution\n */\nimport type { UIElement } from \"../types\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\ninterface PlaceholderInfo {\n  key: string;\n  parentKey: string | null;\n  createdAt: number;\n  referencedBy: Set<string>;\n}\n\ninterface ResolutionResult {\n  resolved: boolean;\n  element: UIElement | null;\n  dependents: string[];\n}\n\n// =============================================================================\n// Placeholder Manager Class\n// =============================================================================\n\nexport class PlaceholderManager {\n  private placeholders: Map<string, PlaceholderInfo> = new Map();\n  private pendingElements: Map<string, UIElement> = new Map();\n  private readonly timeout: number;\n\n  constructor(options: { timeout?: number } = {}) {\n    this.timeout = options.timeout ?? 5000;\n  }\n\n  /**\n   * Create a placeholder for a forward-referenced element\n   */\n  createPlaceholder(key: string, parentKey: string | null): UIElement {\n    // Track placeholder\n    this.placeholders.set(key, {\n      key,\n      parentKey,\n      createdAt: Date.now(),\n      referencedBy: new Set(),\n    });\n\n    // Return placeholder element\n    return {\n      key,\n      type: \"__placeholder__\",\n      props: {\n        _isPlaceholder: true,\n        _createdAt: Date.now(),\n      },\n    };\n  }\n\n  /**\n   * Check if a key is a placeholder\n   */\n  isPlaceholder(key: string): boolean {\n    return this.placeholders.has(key);\n  }\n\n  /**\n   * Register that an element references a placeholder\n   */\n  addReference(placeholderKey: string, referencingKey: string): void {\n    const info = this.placeholders.get(placeholderKey);\n    if (info) {\n      info.referencedBy.add(referencingKey);\n    }\n  }\n\n  /**\n   * Resolve a placeholder with the real element\n   */\n  resolve(key: string, element: UIElement): ResolutionResult {\n    const info = this.placeholders.get(key);\n\n    if (!info) {\n      // Not a placeholder, just store\n      this.pendingElements.set(key, element);\n      return { resolved: true, element, dependents: [] };\n    }\n\n    // Remove from placeholders\n    this.placeholders.delete(key);\n\n    // Get dependents\n    const dependents = Array.from(info.referencedBy);\n\n    return { resolved: true, element, dependents };\n  }\n\n  /**\n   * Check for timed-out placeholders\n   */\n  checkTimeouts(): string[] {\n    const timedOut: string[] = [];\n    const now = Date.now();\n\n    for (const [key, info] of this.placeholders) {\n      if (now - info.createdAt > this.timeout) {\n        timedOut.push(key);\n      }\n    }\n\n    return timedOut;\n  }\n\n  /**\n   * Remove timed-out placeholders\n   */\n  pruneTimedOut(): string[] {\n    const timedOut = this.checkTimeouts();\n\n    for (const key of timedOut) {\n      this.placeholders.delete(key);\n    }\n\n    return timedOut;\n  }\n\n  /**\n   * Get all pending placeholders\n   */\n  getPendingPlaceholders(): string[] {\n    return Array.from(this.placeholders.keys());\n  }\n\n  /**\n   * Get statistics\n   */\n  getStats(): {\n    placeholderCount: number;\n    pendingCount: number;\n    oldestAge: number;\n  } {\n    let oldestAge = 0;\n    const now = Date.now();\n\n    for (const info of this.placeholders.values()) {\n      const age = now - info.createdAt;\n      if (age > oldestAge) oldestAge = age;\n    }\n\n    return {\n      placeholderCount: this.placeholders.size,\n      pendingCount: this.pendingElements.size,\n      oldestAge,\n    };\n  }\n\n  /**\n   * Reset manager state\n   */\n  reset(): void {\n    this.placeholders.clear();\n    this.pendingElements.clear();\n  }\n}\n\n// =============================================================================\n// Factory Function\n// =============================================================================\n\nexport function createPlaceholderManager(options?: {\n  timeout?: number;\n}): PlaceholderManager {\n  return new PlaceholderManager(options);\n}\n","/**\n * Streaming Ports - Hexagonal architecture ports for streaming\n */\nimport type {\n  StreamFrame,\n  StreamMessage,\n  ValidationResult,\n  StreamOptions,\n} from \"./types\";\n\n// =============================================================================\n// Stream Source Port (Primary/Driving)\n// =============================================================================\n\n/**\n * Port for receiving stream data\n */\nexport interface StreamSourcePort {\n  /**\n   * Connect to a stream source\n   */\n  connect(url: string, options?: StreamOptions): Promise<void>;\n\n  /**\n   * Disconnect from the stream source\n   */\n  disconnect(): Promise<void>;\n\n  /**\n   * Subscribe to stream frames\n   */\n  subscribe(callback: (frame: StreamFrame) => void): () => void;\n\n  /**\n   * Subscribe to errors\n   */\n  onError(callback: (error: Error) => void): () => void;\n\n  /**\n   * Get connection status\n   */\n  isConnected(): boolean;\n}\n\n// =============================================================================\n// Stream Sink Port (Secondary/Driven)\n// =============================================================================\n\n/**\n * Port for emitting stream data\n */\nexport interface StreamSinkPort {\n  /**\n   * Send a frame to the stream\n   */\n  send(frame: StreamFrame): Promise<void>;\n\n  /**\n   * Send a message (will be wrapped in a frame)\n   */\n  sendMessage(message: StreamMessage): Promise<void>;\n\n  /**\n   * Flush any buffered data\n   */\n  flush(): Promise<void>;\n\n  /**\n   * Close the stream\n   */\n  close(): Promise<void>;\n}\n\n// =============================================================================\n// Validation Port\n// =============================================================================\n\n/**\n * Port for validating stream data\n */\nexport interface ValidationPort {\n  /**\n   * Validate a frame\n   */\n  validateFrame(frame: unknown): ValidationResult;\n\n  /**\n   * Validate a message\n   */\n  validateMessage(message: unknown): ValidationResult;\n\n  /**\n   * Parse with auto-recovery\n   */\n  parseWithRecovery(data: unknown): {\n    frame: StreamFrame | null;\n    validation: ValidationResult;\n    recovered: boolean;\n  };\n\n  /**\n   * Register component types for validation\n   */\n  registerComponentTypes(types: string[]): void;\n}\n\n// =============================================================================\n// Persistence Port\n// =============================================================================\n\n/**\n * Port for persisting stream state\n */\nexport interface StreamPersistencePort {\n  /**\n   * Save the current stream state\n   */\n  saveState(sessionId: string, state: StreamState): Promise<void>;\n\n  /**\n   * Load a saved stream state\n   */\n  loadState(sessionId: string): Promise<StreamState | null>;\n\n  /**\n   * Delete a saved state\n   */\n  deleteState(sessionId: string): Promise<void>;\n\n  /**\n   * List all saved sessions\n   */\n  listSessions(): Promise<string[]>;\n}\n\n/**\n * Stream state for persistence\n */\nexport interface StreamState {\n  sessionId: string;\n  lastSequence: number;\n  pendingFrames: StreamFrame[];\n  timestamp: number;\n}\n\n// =============================================================================\n// Telemetry Port\n// =============================================================================\n\n/**\n * Port for stream telemetry/observability\n */\nexport interface StreamTelemetryPort {\n  /**\n   * Record a frame received event\n   */\n  recordFrameReceived(frame: StreamFrame): void;\n\n  /**\n   * Record a validation error\n   */\n  recordValidationError(frame: unknown, result: ValidationResult): void;\n\n  /**\n   * Record sequence gap\n   */\n  recordSequenceGap(expected: number, received: number): void;\n\n  /**\n   * Record recovery action\n   */\n  recordRecovery(frame: StreamFrame): void;\n\n  /**\n   * Get metrics\n   */\n  getMetrics(): StreamMetrics;\n}\n\n/**\n * Stream metrics\n */\nexport interface StreamMetrics {\n  framesReceived: number;\n  framesValidated: number;\n  validationErrors: number;\n  recoveries: number;\n  sequenceGaps: number;\n  averageLatency: number;\n}\n\n// =============================================================================\n// No-op Implementations (for testing/defaults)\n// =============================================================================\n\nexport const noopStreamSource: StreamSourcePort = {\n  connect: async () => {},\n  disconnect: async () => {},\n  subscribe: () => () => {},\n  onError: () => () => {},\n  isConnected: () => false,\n};\n\nexport const noopStreamSink: StreamSinkPort = {\n  send: async () => {},\n  sendMessage: async () => {},\n  flush: async () => {},\n  close: async () => {},\n};\n\nexport const noopStreamPersistence: StreamPersistencePort = {\n  saveState: async () => {},\n  loadState: async () => null,\n  deleteState: async () => {},\n  listSessions: async () => [],\n};\n\nexport const noopStreamTelemetry: StreamTelemetryPort = {\n  recordFrameReceived: () => {},\n  recordValidationError: () => {},\n  recordSequenceGap: () => {},\n  recordRecovery: () => {},\n  getMetrics: () => ({\n    framesReceived: 0,\n    framesValidated: 0,\n    validationErrors: 0,\n    recoveries: 0,\n    sequenceGaps: 0,\n    averageLatency: 0,\n  }),\n};\n","/**\n * Cache Port - Caching abstraction\n */\n\n/**\n * Cache entry with metadata\n */\nexport interface CacheEntry<T> {\n  value: T;\n  expiresAt?: number;\n  createdAt: number;\n  tags?: string[];\n}\n\n/**\n * Cache options\n */\nexport interface CacheOptions {\n  ttl?: number; // Time to live in milliseconds\n  tags?: string[];\n}\n\n/**\n * Cache statistics\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  size: number;\n  maxSize: number;\n}\n\n/**\n * Generic cache port\n */\nexport interface CachePort<T = unknown> {\n  get(key: string): Promise<T | null>;\n  set(key: string, value: T, options?: CacheOptions): Promise<void>;\n  delete(key: string): Promise<void>;\n  has(key: string): Promise<boolean>;\n  clear(): Promise<void>;\n  invalidateByTag(tag: string): Promise<void>;\n  getStats(): Promise<CacheStats>;\n}\n\n/**\n * Multi-level cache port (L1: memory, L2: storage)\n */\nexport interface MultiLevelCachePort<T = unknown> extends CachePort<T> {\n  getWithFallback(key: string, fallback: () => Promise<T>): Promise<T>;\n  warmup(keys: string[]): Promise<void>;\n  getLevel(level: number): CachePort<T> | null;\n}\n\n/**\n * No-op cache implementation for testing\n */\nexport const noopCache: CachePort = {\n  get: async () => null,\n  set: async () => {},\n  delete: async () => {},\n  has: async () => false,\n  clear: async () => {},\n  invalidateByTag: async () => {},\n  getStats: async () => ({ hits: 0, misses: 0, size: 0, maxSize: 0 }),\n};\n","/**\n * Memory/Recall Port - AI memory and context persistence\n */\n\n/**\n * Memory item structure\n */\nexport interface MemoryItem {\n  id: string;\n  content: string;\n  embedding?: number[];\n  metadata: {\n    source: string;\n    timestamp: number;\n    importance?: number;\n    tags?: string[];\n  };\n}\n\n/**\n * Memory query options\n */\nexport interface MemoryQueryOptions {\n  limit?: number;\n  minScore?: number;\n  tags?: string[];\n  since?: number;\n}\n\n/**\n * Memory query result\n */\nexport interface MemoryQueryResult {\n  items: Array<MemoryItem & { score: number }>;\n  totalMatches: number;\n}\n\n/**\n * Memory store port for AI context/recall\n */\nexport interface MemoryStorePort {\n  store(item: Omit<MemoryItem, \"id\">): Promise<MemoryItem>;\n  recall(\n    query: string,\n    options?: MemoryQueryOptions,\n  ): Promise<MemoryQueryResult>;\n  forget(id: string): Promise<void>;\n  forgetByTag(tag: string): Promise<void>;\n  consolidate(): Promise<void>; // Merge/compress old memories\n  getStats(): Promise<{\n    totalItems: number;\n    oldestTimestamp: number;\n    newestTimestamp: number;\n  }>;\n}\n\n/**\n * No-op memory store for testing\n */\nexport const noopMemoryStore: MemoryStorePort = {\n  store: async (item) => ({ id: crypto.randomUUID(), ...item }),\n  recall: async () => ({ items: [], totalMatches: 0 }),\n  forget: async () => {},\n  forgetByTag: async () => {},\n  consolidate: async () => {},\n  getStats: async () => ({\n    totalItems: 0,\n    oldestTimestamp: 0,\n    newestTimestamp: 0,\n  }),\n};\n","/**\n * Sync Port - Offline/Online synchronization\n */\n\n/**\n * Sync operation\n */\nexport interface SyncOperation {\n  id: string;\n  type: \"create\" | \"update\" | \"delete\";\n  entityType: string;\n  entityId: string;\n  payload: unknown;\n  timestamp: number;\n  retryCount: number;\n}\n\n/**\n * Sync status\n */\nexport type SyncStatus = \"idle\" | \"syncing\" | \"error\" | \"offline\" | \"conflict\";\n\n/**\n * Sync conflict\n */\nexport interface SyncConflict {\n  operationId: string;\n  localData: unknown;\n  remoteData: unknown;\n  conflictType: \"update-update\" | \"update-delete\" | \"delete-update\";\n}\n\n/**\n * Conflict resolution strategy\n */\nexport type ConflictResolution =\n  | \"local-wins\"\n  | \"remote-wins\"\n  | \"merge\"\n  | \"manual\";\n\n/**\n * Sync port for offline-first operations\n */\nexport interface SyncPort {\n  getStatus(): SyncStatus;\n  getPendingOperations(): Promise<SyncOperation[]>;\n  queueOperation(\n    op: Omit<SyncOperation, \"id\" | \"timestamp\" | \"retryCount\">,\n  ): Promise<string>;\n  sync(): Promise<{\n    synced: number;\n    failed: number;\n    conflicts: SyncConflict[];\n  }>;\n  resolveConflict(\n    conflictId: string,\n    resolution: ConflictResolution,\n  ): Promise<void>;\n  clearPending(): Promise<void>;\n  onStatusChange(callback: (status: SyncStatus) => void): () => void;\n}\n\n/**\n * No-op sync port for testing\n */\nexport const noopSync: SyncPort = {\n  getStatus: () => \"idle\",\n  getPendingOperations: async () => [],\n  queueOperation: async () => crypto.randomUUID(),\n  sync: async () => ({ synced: 0, failed: 0, conflicts: [] }),\n  resolveConflict: async () => {},\n  clearPending: async () => {},\n  onStatusChange: () => () => {},\n};\n"],"mappings":"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","names":["getByPath","z","z","z","z","action","executeAction","z","z","check","z","z","name","action","z"]}